{
  "questions": [
    {
      "id": "17",
      "title": "display：none与visibility:hidden区别",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "3种隐藏元素的方式对比",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gey1zh"
        }
      ],
      "category": "前端编程基础/css/常用属性",
      "tags": ["网易", "字节"],
      "question": "{\"ops\":[{\"insert\":\"display：none与visibility:hidden区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"display: none不占据空间，即不在文档流中，而visibility:hidden还在文档流中。\\ndisplay: none子元素不可见。visibility:hidden的子元素如果设置visibility:visible则还可以看到。\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "18",
      "title": "隐藏元素的方法",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "3种隐藏元素的方式对比",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gey1zh"
        }
      ],
      "category": "前端编程基础/css/常用属性",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"有哪些隐藏元素的方法？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"display: none;\\n visibility: hidden; \\nopacity: 0;\\n也可以用left: -9999px或者transform: translateX(-9999px);将元素移出视口外部。\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "19",
      "title": "css画三角形",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "css三角形",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/wa0cv7"
        }
      ],
      "category": "前端编程基础/css/技巧",
      "tags": ["字节", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"使用css画一个三角形\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"<!DOCTYPE html>  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"<html>  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"<head>  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    <title>test</title>  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    <style type=\\\"text/css\\\">  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        #triangle {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            /*1.内容区面积为0*/  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            width: 0;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            height: 0;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            /*2.设置边框样式*/  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            border: 10px solid;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            border-color: white white red white;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    </style>  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"</head>  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"<body>  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    <div id=\\\"triangle\\\"></div>  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"</body>  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"</html>\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "20",
      "title": "数组排序",
      "type": 3,
      "level": 6,
      "knowledge": [],
      "category": "前端编程基础/js/array",
      "tags": ["腾讯"],
      "question": "{\"ops\":[{\"insert\":\"给下面的数组排序\\nconst a = [\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"{ age: 51 },{ age: 23 },{ age: 53 },{ age: 12 },{ age: 24 },{ age: 33 }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"];\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"function sort(arr) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return arr.sort(({age: a}, {age: b}) => a - b);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "21",
      "title": "箭头函数和普通函数有什么区别",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "箭头函数",
          "url": "https://es6.ruanyifeng.com/?search=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&x=7&y=8#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"
        }
      ],
      "category": "前端编程基础/js/es6",
      "tags": ["百度", "阿里", "腾讯", "美团", "滴滴", "网易"],
      "question": "{\"ops\":[{\"insert\":\"箭头函数和普通函数有什么区别？\\n箭头函数为什么不能用作构造函数？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"区别：\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"1.\"},{\"insert\":\" 箭头函数在一些情况下书写更简洁（如只有一个参数、函数体直接返回值时候）。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"2.\"},{\"insert\":\" 箭头函数没有自己的this，箭头函数内的this变量指向外层非箭头函数的函数的this，或者将该箭头函数作为属性的对象。箭头函数也不支持call()/apply()函数特性。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"3.\"},{\"insert\":\" 箭头函数内部不可以使用arguments对象。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"4.\"},{\"insert\":\" 箭头函数不可以当做构造函数。\\n\\n为什么不能用作构造函数：\\n构造函数是通过new关键字来生成对象实例，生成对象实例的过程也是通过构造函数给实例绑定this的过程，而箭头函数没有自己的this。创建对象过程，new 首先会创建一个空对象，并将这个空对象的__proto__指向构造函数的prototype，从而继承原型上的方法，但是箭头函数没有prototype。因此不能使用箭头作为构造函数，也就不能通过new操作符来调用箭头函数。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "22",
      "title": "暂时性死区",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "暂时性死区",
          "url": "https://es6.ruanyifeng.com/#docs/let#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"
        }
      ],
      "category": "前端编程基础/js/es6",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"暂时性死区的定义？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\\n\"}]}",
      "quizes": []
    },
    {
      "id": "23",
      "title": "es6继承中的静态成员",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "es6继承",
          "url": "https://es6.ruanyifeng.com/#docs/class-extends"
        }
      ],
      "category": "前端编程基础/js/es6",
      "tags": ["字节", "京东"],
      "question": "{\"ops\":[{\"insert\":\"es6继承，子类会继承父类的静态成员吗？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"会继承，除了私有属性，父类的所有属性和方法，都会被子类继承，其中包括静态方法。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "24",
      "title": "es6类继承的super",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "es6 class继承",
          "url": "https://es6.ruanyifeng.com/#docs/class-extends#super-%E5%85%B3%E9%94%AE%E5%AD%97"
        }
      ],
      "category": "前端编程基础/js/es6",
      "tags": [],
      "question": "{\"ops\":[{\"insert\":\"ES6继承为什么需要super？不执行super有什么问题？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。\\n\\n如果存在继承，则子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "25",
      "title": "定义在Class里的方法定义在类上面还是原型上面？",
      "type": 1,
      "level": 12,
      "knowledge": [],
      "category": "前端编程基础/js/es6",
      "tags": [],
      "question": "{\"ops\":[{\"insert\":\"定义在Class里的方法定义在类上面还是原型上面？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"方法定义在原型上，属性定义在实例上。\\nclass Test {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    // 实例上\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    name = '';\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    // 原型上\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    log() {}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    // 实例上\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    log1 = () => {};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "26",
      "title": "解构赋值",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "es6解构赋值",
          "url": "https://es6.ruanyifeng.com/#docs/destructuring"
        }
      ],
      "category": "前端编程基础/js/es6",
      "tags": [],
      "question": "{\"ops\":[{\"insert\":\"讲一下es6的解构赋值\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"参考知识点链接\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "27",
      "title": "异步代码执行结果",
      "type": 4,
      "level": 12,
      "knowledge": [
        {
          "name": "promise",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca"
        },
        {
          "name": "js事件循环",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dm2emf"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["百度", "阿里"],
      "question": "{\"ops\":[{\"insert\":\"说出下面代码执行结果\\nconst promise = new Promise((resolve,reject)=>{\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(1);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    resolve();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(2);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    reject()\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"})\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"setTimeout(()=>{console.log(5)},0)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"promise.then(()=>{console.log(3)})\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\".then(()=>{console.log(6)})\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\".catch(()=>{console.log(7)})\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(4)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"答案是1,2,4,3,6,5\\n首先new Promise时候打印1和2，因为new Promise时候会立即执行传入的方法\\n然后后面代码都是异步代码，先将setTimeout的回调加入宏任务队列，再把promise.then放入到微任务队列，然后直接执行最后一句，打印4\\n这样宏任务代码执行完了，接下来开始执行微任务队列中的任务，由于promise resolve，因为promise resolve之后状态不会再改变，因此不会执行到reject的对调，所以打印3和6\\n微任务队列为空，再到宏任务队列中查找任务，找到setTimeout回调执行，打印5\\n调用栈、宏任务队列、微任务队列都为空，代码执行结束。\\n\"}]}",
      "quizes": ["5", "6"]
    },
    {
      "id": "28",
      "title": "异步代码执行结果",
      "type": 4,
      "level": 12,
      "knowledge": [
        {
          "name": "promise",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca"
        },
        {
          "name": "js事件循环",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dm2emf"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["百度", "阿里"],
      "question": "{\"ops\":[{\"insert\":\"说出代码执行结果\\nconst first = () => (new Promise((resolve, reject) => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(3);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    let p = new Promise((resolve, reject) => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        console.log(7);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        setTimeout(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            console.log(5);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            resolve();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }, 0);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        resolve(1);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    });\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    resolve(2);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    p.then((arg) => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        console.log(arg);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    });\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}));\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"first().then((arg) => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(arg);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"});\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(4);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"3, 7, 4, 1, 2, 5\\n首先定义first\\n然后执行first，然后执行new Promise传入的方法，先打印3\\n又new Promise，执行其中传入的方法，打印7\\n执行setTimeout，将回调放入宏任务队列\\n执行resolve(1)，将内部promise状态置为fullfilled，值为1\\n执行resolve(2)，将外部promise状态置为fullfilled，值为2\\n执行内部promise.then方法，将回调加入微任务队列\\n执行first().then，即外部的promise，将回调加入到微任务队列\\n调用栈为空，开始从微任务队列拿取任务，首先拿到内部promise的回调，打印其值1\\n然后从微任务队列中拿取外部的promise的回调，打印其值2\\n此时微任务队列为空，开始从宏任务队列中拿取任务，即setTimeout回调，打印5。\\n调用栈，宏任务队列和微任务队列都为空，执行结束。\\n\"}]}",
      "quizes": ["5", "6"]
    },
    {
      "id": "29",
      "title": "异步代码执行结果",
      "type": 4,
      "level": 12,
      "knowledge": [
        {
          "name": "promise",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca"
        },
        {
          "name": "js事件循环",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dm2emf"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"说出代码执行结果\\nconsole.log(1);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"new Promise(resolve => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    resolve();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(2);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}).then(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(3);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"})\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"setTimeout(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(4);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}, 0);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(5);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"1,2,5,3,4\\n先打印1\\n执行new Promise的函数，打印2\\n执行promise.then，将回调加入微任务队列\\n将setTimeout的回调加入宏任务队列\\n打印5\\n调用栈为空，取微任务队列中的任务执行，打印3\\n微任务队列为空，取宏任务队列任务执行，打印5\\n调用栈、微任务队列、宏任务队列都为空，执行结束\\n\\n\"}]}",
      "quizes": ["5", "6"]
    },
    {
      "id": "30",
      "title": "异步代码执行结果",
      "type": 4,
      "level": 12,
      "knowledge": [
        {
          "name": "promise",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca"
        },
        {
          "name": "js事件循环",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dm2emf"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"说出代码执行结果\\nPromise.resolve()\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\".then(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log('1');\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"})\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\".then(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log('2');\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"});\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"setTimeout(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    Promise.resolve()\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    .then(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        console.log('3');\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    })\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    .then(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        console.log('4');\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    });\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    setInterval(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        console.log('5');\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }, 3000);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log('6');\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}, 0);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"1,2,6,3,4,5,5...\\n先执行Promise.resolve，将两个回调加入到微任务队列中\\n执行setTimeout，将其回调加入宏任务队列\\n调用栈为空，拿出微任务队列中的两个回调执行，打印1,2\\n微任务队列为空，拿出宏任务队列中的setTimeout的回调执行\\n将setTimeout中的Promise.resolve的两个回调加入到微任务队列\\n将setTimeout中的setInterval的回调加入宏任务队列\\n打印6\\n取出微任务队列中的两个Promise的回调，打印3,4\\n取宏任务队列中的setInterval的回调执行，每隔3s符合执行条件，打印5。注意setInterval调用时候不马上会执行一次，第一次执行是3s以后。\\n\"}]}",
      "quizes": ["5", "6"]
    },
    {
      "id": "31",
      "title": "异步代码执行结果",
      "type": 4,
      "level": 12,
      "knowledge": [
        {
          "name": "promise",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca"
        },
        {
          "name": "js事件循环",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dm2emf"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["网易"],
      "question": "{\"ops\":[{\"insert\":\"说出代码执行结果\\nsetTimeout(function() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(1);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}, 0);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(2);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"async function s1() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(7)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    await s2();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(8);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"asycn function s2() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(9);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"s1();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"new Promise((resolve, reject) => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(3);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    resolve();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(6);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}).then(() => console.log(4))\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(5);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"2,7,9,3,6,5,8,4,1\\n记住async只是promise的语法糖，转化为等价的形式就好分析了\\n先执行setTimeout，加入宏任务队列中\\n打印2\\n执行s1，同步打印7\\n执行s2，同步打印3\\n执行完s2，将console.log(8)加入到微任务队列\\n然后执行s1后面的Promise，打印3和6\\n执行then，将console.log(4)加入到微任务队列中\\n打印5\\n调用栈为空，将微任务队列中的两个任务依次拿出来执行，打印8和4\\n微任务队列执行完，将宏任务队列的任务拿出来执行，打印1\\n调用栈、微任务队列、宏任务队列都为空，执行完毕。\\n\"}]}",
      "quizes": ["5", "6"]
    },
    {
      "id": "32",
      "title": "讲讲promise",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "promise",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["字节", "美团", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"讲讲promise，promise的3种状态和状态转换。\\nPromise中回调函数是同步的还是异步的？then的链式调用是同步的还是异步的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点链接\\n\"}]}",
      "quizes": ["5", "6", "14"]
    },
    {
      "id": "33",
      "title": "apply、bind、call",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "js中的this指向",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ruk1qu/edit#M2Nf8"
        }
      ],
      "category": "前端编程基础/js/this",
      "tags": ["百度", "美团", "京东", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"说下call、apply、bind方法的作用和区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"call、apply、bind都是用来改变this指向的，\\ncall和apply调用时候立即执行，bind调用返回新的函数。\\n当需要传递参数时候，call直接写多个参数，apply将多个参数写成数组。\\nbind在绑定时候需要固定参数时候，也是直接写多个参数。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "34",
      "title": "改变this指向的方法",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "js中的this指向",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ruk1qu"
        }
      ],
      "category": "前端编程基础/js/this",
      "tags": ["百度", "快手"],
      "question": "{\"ops\":[{\"insert\":\"改变this指向的方法都有哪些？它们的区别是什么呢？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"call、apply、bind都是用来改变this指向的，\\ncall和apply调用时候立即执行，bind调用返回新的函数。\\n当需要传递参数时候，call直接写多个参数，apply将多个参数写成数组。\\nbind在绑定时候需要固定参数时候，也是直接写多个参数。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "35",
      "title": "说出下面代码输出结果",
      "type": 4,
      "level": 6,
      "knowledge": [
        {
          "name": "js this指向",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ruk1qu/edit#M2Nf8"
        }
      ],
      "category": "前端编程基础/js/this",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"说出代码执行结果\\nvar num = 1;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var obj = {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    num:2,\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    add:function(){\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        this.num = 3;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        (function(){\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            console.log(this.num);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            this.num = 4\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        })();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        console.log(this.num);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"obj.add()\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"答案是1,3。\\n第一个log在匿名函数中，它的执行在全局范围，因此this指向全局环境，num是最外层的1。\\n第二个log在add方法中，add方法是通过obj.add()调用的，因此this指向obj，所以num是上面修改后的3。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "36",
      "title": "typescript泛型",
      "type": 1,
      "level": 8,
      "knowledge": [
        {
          "name": "typescript泛型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/levwe9#VPz3r"
        }
      ],
      "category": "前端编程基础/js/typescript",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"讲讲typescript泛型\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点链接\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "37",
      "title": "实现防抖方法",
      "type": 3,
      "level": 14,
      "knowledge": [
        {
          "name": "防抖和节流",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/yg2pez"
        }
      ],
      "category": "前端编程基础/js/util",
      "tags": ["百度", "滴滴", "网易", "快手", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"实现防抖方法\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"function debounce(fn, delay=500) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    let timer = null;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"    return function() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        if (timer) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            clearTimeout(timer)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        timer = setTimeout(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            fn.apply(this, arguments);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            timer = null;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }, delay)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "38",
      "title": "实现深拷贝和浅拷贝",
      "type": 3,
      "level": 2,
      "knowledge": [
        {
          "name": "深拷贝和浅拷贝",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/kha36o"
        }
      ],
      "category": "前端编程基础/js/util",
      "tags": ["百度", "阿里", "字节", "滴滴", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"实现深拷贝和浅拷贝。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"深拷贝\\nfunction checkType(any) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  return Object.prototype.toString.call(any).slice(8, -1)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function clone(any){\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  if(checkType(any) === 'Object') { // 拷贝对象\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    let o = {};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    for(let key in any) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"      o[key] = clone(any[key])\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return o;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  } else if(checkType(any) === 'Array') { // 拷贝数组\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var arr = []\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    for(let i = 0,leng = any.length;i<leng;i++) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"      arr[i] = clone(any[i])\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return arr;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  } else if(checkType(any) === 'Function') { // 拷贝函数\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return new Function('return '+any.toString()).call(this)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  } else if(checkType(any) === 'Date') { // 拷贝日期\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return new Date(any.valueOf())\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  } else if(checkType(any) === 'RegExp') { // 拷贝正则\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return new RegExp(any)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  } else if(checkType(any) === 'Map') { // 拷贝Map 集合\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    let m = new Map()\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    any.forEach((v,k)=>{\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"      m.set(k, clone(v))\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    })\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return m\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  } else if(checkType(any) === 'Set') { // 拷贝Set 集合\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    let s = new Set()\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    for(let val of any.values()) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"      s.add(clone(val))\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return s\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  return any;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"\\n浅拷贝\\n\\nfunction shallowCopy(src) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  var dst = {};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  for (var prop in src) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    if (src.hasOwnProperty(prop)) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"      dst[prop] = src[prop];\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  return dst;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "39",
      "title": "获取当前时间，并格式化",
      "type": 3,
      "level": 4,
      "knowledge": [],
      "category": "前端编程基础/js/util",
      "tags": [],
      "question": "{\"ops\":[{\"insert\":\"获取当前时间，并格式化成\\\"yyyy-mm-dd\\\"格式\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"function getNowFormatDate() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var date = new Date();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var seperator = \\\"-\\\";\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var year = date.getFullYear();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var month = date.getMonth() + 1;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var strDate = date.getDate();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    if (month >= 1 && month <= 9) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        month = \\\"0\\\" + month;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    if (strDate >= 0 && strDate <= 9) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        strDate = \\\"0\\\" + strDate;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var currentdate = year + seperator + month + seperator + strDate;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return currentdate;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "40",
      "title": "实现lodash中的_get方法",
      "type": 3,
      "level": 12,
      "knowledge": [],
      "category": "前端编程基础/js/util",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"// input\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const obj = { 选择器: { to: { toutiao: \\\"FE Coder\\\"} }, target: [1, 2, { name: 'byted'}]};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"get(obj, '选择器.to.toutiao', 'target[0]', 'target[2].name');\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// output\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"['FE coder', 1, 'byted']\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"function get(object, ...path) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return path.map((item) => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        let res = object;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        item.replace(/\\\\[/g, \\\".\\\")\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            .replace(/\\\\]/g, \\\"\\\")\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            .split('.')\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            .map(path => res = res && res[path]);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        return res;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    })\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "41",
      "title": "讲一下event loop",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "JavaScript事件循环",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dm2emf"
        }
      ],
      "category": "前端编程基础/js/事件循环",
      "tags": ["百度", "阿里", "字节", "滴滴", "快手"],
      "question": "{\"ops\":[{\"insert\":\"讲一下eventloop？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"事件循环是js引擎执行js的机制，用来实现js的异步特性。\\n\\n事件循环的过程为：当执行栈空的时候，就会从任务队列中，取任务来执行。共分3步：\\n\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"1.\"},{\"insert\":\" 取一个宏任务来执行。执行完毕后，下一步。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"2.\"},{\"insert\":\" 取一个微任务来执行，执行完毕后，再取一个微任务来执行。直到微任务队列为空，执行下一步。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"3.\"},{\"insert\":\" 更新UI渲染。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "42",
      "title": "宏任务和微任务的区别",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "JavaScript事件循环",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dm2emf"
        }
      ],
      "category": "前端编程基础/js/事件循环",
      "tags": ["字节", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"宏任务和微任务的区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"1.\"},{\"insert\":\" 宏任务队列可以有多个，微任务队列只有一个\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"2.\"},{\"insert\":\" 宏任务有 script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering。微任务有 process.nextTick, Promise, Object.observer, MutationObserver。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"3.\"},{\"insert\":\" 宏任务队列有优先级之分。每次js引擎从宏任务队列中取宏任务时，会按照优先级选择宏任务队列，若高优先级的宏任务队列中没有任务时，才会到低级的宏任务队列中去取任务。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"4.\"},{\"insert\":\" 为什么会有宏任务和微任务之分呢？个人理解，宏任务才是真正意义上的任务，而微任务相当于宏任务的附属的一系列操作和相应。所以，js引擎每次取出一个宏任务执行，并且执行相关的微任务，这样保证一个完整的任务被执行完。这也是微任务队列只有一个的原因，微任务队列就是用来辅助宏任务队列的任务的完整执行的。而宏任务队列才是真正意义的任务，任务有优先级之分就很好理解了，因此才有多个宏任务队列，就是为了区分优先级。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "43",
      "title": "如何理解作用域",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "js作用域",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#tYUhx"
        }
      ],
      "category": "前端编程基础/js/作用域",
      "tags": ["百度", "美团", "阿里", "京东"],
      "question": "{\"ops\":[{\"insert\":\"如何理解js的作用域\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"作用域是可访问变量的集合或者说范围（例如全局的范围、函数的范围、语句块的范围），在作用域内，变量可访问，在作用域外变量不可访问。\\n\\njs是词法作用域，变量的访问范围仅由声明时候的区域决定。\\n\\n从变量查找的范围的角度，js的作用域可以分为3类：全局作用域、函数作用域和块级作用域。\\n全局作用域是在全局环境下声明的变量。在任意位置可以访问到。\\n函数作用域是在函数内部声明的变量，函数内部和函数内部声明的函数中都可以访问到。访问变量时候先在函数内部找，找不到则在外层函数中找，直到全局作用域，形成“作用域链”。\\n函数作用域有“变量提升”和“函数声明提升”的特性。\\n块级作用域指在语句块声明的变量，使用let和const声明的变量才作用于块级作用域，块级作用域没有变量提升。\\n\\n\"}]}",
      "quizes": ["5", "7"]
    },
    {
      "id": "44",
      "title": "两个for循环的区别",
      "type": 1,
      "level": 14,
      "knowledge": [],
      "category": "前端编程基础/js/基础",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"有两个for循环\\n// 1\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"for (var i = 0; i < 10; i++) {}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// 2\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"for (var i = 0; i < arr.length; i++) {}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"\\n它们有什么区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"第一个for循环的终止条件是固定的，第二个for循环的终止条件是动态的。\\n因此如果第二个循环体内修改arr数组，可能导致循环次数和初始的arr.length不同。\\n另外第二个循环每次读取arr.length有性能损耗，因此当循环次数相同时候，执行速度不如第一个for循环。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "45",
      "title": "如何判断数组",
      "type": 3,
      "level": 14,
      "knowledge": [
        {
          "name": "如何判断数组类型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#VXJZG"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["百度", "阿里", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"js如何判断一个变量是数组？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"// ES6中增加的数组方法\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"Array.isArray()\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// 使用constructor判断\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function isArray(arr) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return arr.constructor.toString().indexOf(\\\"Array\\\") > -1;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"function isArray(arr) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return arr.constructor === Array;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// 用instanceof判断\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function isArray(arr){ \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return arr instanceof Array; \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "8", "14"]
    },
    {
      "id": "46",
      "title": "js数据类型",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "js数据类型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#tz3Xf"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["百度", "网易", "腾讯", "字节", "京东"],
      "question": "{\"ops\":[{\"insert\":\"js数据类型都有哪些？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"js数据类型有6种：\\nnumber\\nstring\\nboolean\\nobject\\nfunction\\nundefined\\n\\n其中number、string、boolean、undefined是值类型，function和object是引用类型。\\n\"}]}",
      "quizes": ["5", "8", "14"]
    },
    {
      "id": "47",
      "title": "==和===区别",
      "type": 1,
      "level": 2,
      "knowledge": [
        {
          "name": "js数据类型转换规则",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#iS35D"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["网易", "阿里", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"==和===区别是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"===如果类型不同返回false，如果类型相同则比较值是否相同，注意引用类型对象之和自身相等。\\n== 转换规则：  如果是类型相同，直接进行===比较，如果类型不同，要进行转换再比较。\\n\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "48",
      "title": "代码执行结果",
      "type": 4,
      "level": 6,
      "knowledge": [
        {
          "name": "js值类型和引用类型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#YFdbY"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"var a = {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    name:1,\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    age:2,\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var b = a;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"b.name = 3；\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"console.log(a);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(b);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"a是引用类型，赋值给b后，变量b持有引用，修改b就修改了原始的数据。\\na: {name: 3, age: 2}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"b: {name: 3, age: 2}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "49",
      "title": "装箱拆箱",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "包装类型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#Bw1lu"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"讲一下js中的包装类型\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"基础类型的数据在使用时候，js引擎会先将之包装为对象，语句执行完对象被销毁。这个过程也被称为“装箱拆箱”。\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "50",
      "title": "js类型的隐式转换",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "隐式转换",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#mJSDr"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["腾讯"],
      "question": "{\"ops\":[{\"insert\":\"讲一下js类型的隐式转换\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"在一些场景中，不同类型的变量会放在一起处理，这时候js引擎会做隐式转换转，转换为相同的类型后再处理。还有些情况下对变量的类型有要求，而变量如果不符合要求就会进行隐式转换（如if语句要求是bool值，如果是非bool值，会先转换为bool再处理）。\\n隐式转换的场景和规则参见知识点链接。\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "51",
      "title": "为什么3.tostring()会报错？",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "包装类型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#Bw1lu"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"为什么3.tostring()会报错？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"因为会解析成小数点\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "52",
      "title": "什么是柯里化",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "柯里化",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cghxkr"
        }
      ],
      "category": "前端编程基础/js/柯里化",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"什么是柯里化\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"柯里化，英语：Currying，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "53",
      "title": "提取字符串中的数字",
      "type": 3,
      "level": 12,
      "knowledge": [],
      "category": "前端编程基础/js/正则",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"提取字符串中的数字\\ninput: \\\"abc123ds45\\\"\\noutput: [123, 45]\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"function extractDigit(str) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return str.match(/\\\\d+/g);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "54",
      "title": "正则表达式中问号的作用",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "js正则表达式",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/zwvzl3#oIINl"
        }
      ],
      "category": "前端编程基础/js/正则",
      "tags": ["阿里"],
      "question": "{\"ops\":[{\"insert\":\"正则表达式中问号的作用是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"问号有3中作用，不同场景下作用不同\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"1.\"},{\"insert\":\" 作为数量量词，表示0个或者多个。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"2.\"},{\"insert\":\" 用来修饰量词，表示惰性匹配。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"3.\"},{\"insert\":\" (?=p)和(?!p)用来匹配位置。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "55",
      "title": "实现函数，每次调用返回值加一",
      "type": 3,
      "level": 6,
      "knowledge": [],
      "category": "前端编程基础/js/闭包",
      "tags": ["腾讯"],
      "question": "{\"ops\":[{\"insert\":\"const func = (function () {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  // TODO 请实现对应代码逻辑，每调用一次返回值都会加1\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"})();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"const func = (function () {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    let result = 0;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return () => result++;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"})();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "56",
      "title": "如何理解闭包",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "闭包",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#WW3FR"
        }
      ],
      "category": "前端编程基础/js/闭包",
      "tags": ["百度", "腾讯", "网易", "阿里", "滴滴", "拼多多", "美团"],
      "question": "{\"ops\":[{\"insert\":\"如何理解闭包，为什么有这种特性？为什么需要闭包？闭包的缺点？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"对闭包的理解：\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"1.\"},{\"insert\":\" 什么是闭包？函数和函数内部能访问到的变量的总和，就是一个闭包。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"2.\"},{\"insert\":\" 如何生成闭包? 函数嵌套 + 内部函数被引用。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"3.\"},{\"insert\":\" 闭包作用？隐藏变量，避免放在全局有被篡改的风险。\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"4.\"},{\"insert\":\" 使用闭包的注意事项？不用的时候解除引用，避免不必要的内存占用。\\n\\n为什么有闭包的这种特性：如果形成闭包，外部函数执行完后，其中的局部变量可能被内部函数使用，所以不能销毁，因此内部函数能一致访问到这些局部变量，直到引用解除。\\n\\n为什么需要闭包？隐藏变量，避免放在全局有被篡改的风险。\\n\\n闭包的缺点：使用时候不注意的话，容易产生内存泄漏。\\n\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "57",
      "title": "js内存泄漏",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "js闭包",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#WW3FR"
        }
      ],
      "category": "前端编程基础/js/闭包",
      "tags": ["百度", "美团", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"讲一下js内存泄漏是怎么回事？如何避免？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"由于使用闭包但未及时销毁，会导致闭包中的私有变量一直存在于内存中，导致了js的内存泄漏。应该及时销毁不用的闭包变量，从而避免内存泄漏。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "58",
      "title": "写一个闭包",
      "type": 3,
      "level": 6,
      "knowledge": [
        {
          "name": "js闭包",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#WW3FR"
        }
      ],
      "category": "前端编程基础/js/闭包",
      "tags": ["百度", "字节"],
      "question": "{\"ops\":[{\"insert\":\"写一个闭包。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"函数内嵌套函数，并且函数执行完后，内部函数会被引用，这样内部函数可以访问外部函数中定义的变量，于是就生成了一个闭包。\\nfunction outer() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var a = 1;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    function inner() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        console.log(a);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return inner;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"var b = outer();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "59",
      "title": "项目中用到闭包的地方",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "js闭包",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#WW3FR"
        }
      ],
      "category": "前端编程基础/js/闭包",
      "tags": ["百度", "网易"],
      "question": "{\"ops\":[{\"insert\":\"项目中有哪些地方用到了闭包？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"项目通常使用ESM模块规范，不使用闭包封装模块，闭包通常在工具方法的高阶函数中用到，例如防抖节流，React的高阶组件也算是一个闭包。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "60",
      "title": "如何理解原型与原型链",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "原型和原型链",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tf43ma#A2TvE"
        }
      ],
      "category": "前端编程基础/js/面向对象",
      "tags": ["网易", "阿里", "腾讯", "美团", "滴滴", "京东", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"如何理解原型与原型链？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"构造函数有个prototype对象（原型），该对象有个“constructor”属性，指向构造函数。\\n每个对象都有一个“proto”属性，指向它的构造函数的“prototype”属性。\\n构造函数的prototype对象，也有一个“proto”对象，它指向Object的prototype对象。\\n当我们访问对象中的属性时候，会先访问该对象中的本身的属性（私有属性），如果访问不到，会查找对象的“proto”指向的构造函数的prototype对象，如果其中有要访问的属性，就使用该值，否则继续访问prototype的“proto”，在其中查找要访问属性。这样一直上溯到Object对象。这个就是“原型链”。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "61",
      "title": "js继承",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "js继承",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dqgx5e"
        }
      ],
      "category": "前端编程基础/js/面向对象",
      "tags": ["百度", "阿里", "腾讯", "美团", "拼多多", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"js有哪些继承方法？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"主要有几种\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"1.\"},{\"insert\":\" 原型继承\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"2.\"},{\"insert\":\" 借用构造函数继承\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"3.\"},{\"insert\":\" 组合继承\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"4.\"},{\"insert\":\" 寄生组合式继承\\n具体的继承方法和示例代码请看知识点链接。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "62",
      "title": "js创建类",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "js原型的概念",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tf43ma#A2TvE"
        },
        {
          "name": "es6的类",
          "url": "https://es6.ruanyifeng.com/#docs/class"
        }
      ],
      "category": "前端编程基础/js/面向对象",
      "tags": ["阿里"],
      "question": "{\"ops\":[{\"insert\":\"js如何创建一个类？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"js中一个函数就是一个类\\nfunction Test() {}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"\\n通过new来调用，就会实例化该类。通常作为类的函数的名字开头大写以区别于普通函数。\\n\\n也可以使用es6的class语法来创建一个类\\nclass Test {}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "63",
      "title": "说出代码执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [
        {
          "name": "原型链",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tf43ma#A2TvE"
        },
        {
          "name": "js中的this",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ruk1qu#BAHGA"
        }
      ],
      "category": "前端编程基础/js/面向对象",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"说出代码执行结果\\nfunction a() {this.b = 3;}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var c = new a();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"a.prototype.b = 9;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var b = 7;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"a();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(b);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(c.b);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"类a是直接调用，this指向window，因此全局变量b被置为3。访问c.b时候，先查找实例属性，由于实例属性已经被赋值3，因此结果是3。\\n输出结果：3,3\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "64",
      "title": "写一个继承",
      "type": 3,
      "level": 14,
      "knowledge": [
        {
          "name": "寄生组合继承",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dqgx5e#zSrbB"
        }
      ],
      "category": "前端编程基础/js/面向对象",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"手写一个继承\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"寄生组合式继承\\n// 根据传入的父类生成只继承父类原型的对象\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function geSubtPrototype(SuperType) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    function Func() {}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  Func.prototype = SuperType.prototype;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  return new Func();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"function SuperType(property) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    this.property = property;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"SuperType.prototype.getSuperValue = function () {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return this.property;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"function SubType(property, subProperty) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    SuperType.call(this, property);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  this.subProperty = subProperty;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"SubType.prototype = geSubtPrototype(SuperType);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"SubType.prototype.getSubValue = function () {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return this.subProperty;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "65",
      "title": "react fiber",
      "type": 1,
      "level": 8,
      "knowledge": [
        {
          "name": "React concurrent mode",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/rd78rg#LpawA"
        }
      ],
      "category": "前端编程基础/框架/react/原理",
      "tags": ["百度", "字节"],
      "question": "{\"ops\":[{\"insert\":\"React Fiber架构的原理是什么？为什么需要Fiber？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"fiber架构是为了支持react进行可中断渲染，降低卡顿，提升流畅度。\\nreact16之前的版本，diff虚拟dom时候是一口气完成的。这可能造成卡顿，因为人眼可识别的帧率是1s 60帧，即16ms一帧，如果diff时间超过16ms，阻塞渲染，就会感觉卡顿。\\n为了避免这种情况，需要让diff操作不超过16ms，如果超过16ms，就先暂停，让给浏览器进行渲染操作，后续渲染间隙再继续diff。\\nfiber架构就是为了支持这种“可中断渲染”而涉及的。fiber tree是一种数据结构，它把虚拟dom tree连接成一个链表，从而可以让遍历操作可以支持断点重启。\\n\"}]}",
      "quizes": ["5", "10", "14"]
    },
    {
      "id": "66",
      "title": "react的hook",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "hook",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tgc3uo#WV7QL"
        }
      ],
      "category": "前端编程基础/框架/react/基础用法",
      "tags": ["百度", "阿里"],
      "question": "{\"ops\":[{\"insert\":\"react hook的好处和限制是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"hook是react提供的一类API，它给函数式组件增加状态和逻辑，并将功能代码聚合在一起。\\nhook好处是能够让不同功能代码更聚合，更好维护。\\n限制是：\\n1、只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。\\n2、只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中）\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "67",
      "title": "redux api",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "redux都有哪些api？",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gd90zo#nlp2F"
        }
      ],
      "category": "前端编程基础/框架/react/redux",
      "tags": ["百度", "京东"],
      "question": "{\"ops\":[{\"insert\":\"redux都有哪些api？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"applyMiddleware方法，应用中间件\\ncreateStore方法，创建store\\nstore.dispatch方法，触发action\\nstore.getState，获取当前状态\\nstore.subscribe，监听状态改变\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "68",
      "title": "react diff算法",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "react diff算法",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ghwsyx#373432ec"
        }
      ],
      "category": "前端编程基础/框架/react/原理",
      "tags": ["百度", "美团", "滴滴", "网易"],
      "question": "{\"ops\":[{\"insert\":\"讲一下react的diff算法\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"React的diff算法基于两个假设：\\n1、不同元素的类型会产生不同的树\\n2、开发者可以通过key prop标识一个元素在不同的渲染下可以保持稳定（及相同key的元素不需要更新整个元素，不同的key需要更新整个元素）\\n\\n基于上述假设，React认为在视图更新前后，如果两个节点的Tag名（对于原生标签）或者组件（对于自定义组件）相同，则它们是同一个节点，而且如果是不同的根节点，那么子节点也不需要对比，直接用新树替换掉旧的树即可。\\n\\n对比的过程\\n1、当一个组件触发更新（setState），则React会diff以这个组件为根节点的整个虚拟DOM树，对比更新后的虚拟DOM和更新前的虚拟DOM。\\n2、如果两个节点不同，则用新的节点替换掉旧的节点；如果两个节点相同（假设为oldNode和newNode），则对比它们的属性、innerText和子节点。\\n3、如果oldNode有某个子节点someOldChild，而newNode没有这个子节点（即newNode没有一个子节点，和someOldNode有相同的tag名、自定义组件引用或者key值），则删掉someOldChild；如果newNode有某个子节点somNewChild，而oldNode没有，则添加someNewChild；如果oldNode和newNode都有某个节点someChild，则将其移动到正确的位置，并递归地进行对比工作，即以someChild为根节点对比新旧两棵虚拟DOM树。\\n\\n从上面的对比过程可以看出，React的diff（其实Vue也是一样）并不会考虑到节点跨层移动的情况，因此有些观点认为React的对比过程可以描述为“按层比较”（level by level）。\\n\"}]}",
      "quizes": ["5", "10", "14"]
    },
    {
      "id": "69",
      "title": "react异步渲染",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "setState",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tgc3uo#rZFEP"
        }
      ],
      "category": "前端编程基础/框架/react/原理",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"介绍下react异步渲染\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"出于性能考虑，React将setState进行异步处理，即调用setState时候不会马上更新，而是将setState的值放入一个队列，然后延时批量处理队列中的state，进行渲染。\\n\"}]}",
      "quizes": ["10"]
    },
    {
      "id": "70",
      "title": "setState原理",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "关于setState",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tgc3uo#rZFEP"
        }
      ],
      "category": "前端编程基础/框架/react/原理",
      "tags": ["滴滴"],
      "question": "{\"ops\":[{\"insert\":\"setState原理，它是如何实现状态更改的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"参考知识点链接\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "71",
      "title": "react高阶组件的作用",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "react高阶组件的作用",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tgc3uo#4dd95b7a"
        }
      ],
      "category": "前端编程基础/框架/react/基础用法",
      "tags": ["阿里", "美团"],
      "question": "{\"ops\":[{\"insert\":\"React高阶组件的作用有哪些？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"高阶组件用来在不同的React组件之间共享一些逻辑。\\n\\n分离高层和底层关注点：HOC只关注数据的的逻辑，而不关心数据怎么用；参数组件只关注数据如何使用，而不关注数据的逻辑。\\n\\n总而言之，高阶组件就是一个生成组件的工厂方法，在我们需要对某些组件进行改造生成新的组件的时候，可以使用高阶组件。\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "72",
      "title": "对react的理解",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "react简介",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/iui0gp#rrpVy"
        }
      ],
      "category": "前端编程基础/框架/react/基础用法",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"谈谈对react的理解\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点链接\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "73",
      "title": "react的context",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "React context",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tgc3uo#ANiPB"
        }
      ],
      "category": "前端编程基础/框架/react/基础用法",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"介绍一下react的context\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点链接\\n\"}]}",
      "quizes": ["", "10"]
    },
    {
      "id": "74",
      "title": "函数式组件和类组件的区别",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "函数式组件",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tgc3uo#nz0Nw"
        }
      ],
      "category": "前端编程基础/框架/react/基础用法",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"函数式组件和类组件的区别\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"一个返回JSX的函数，就是一个函数式组件。\\n\\n如果一个组件没有生命周期钩子和state，可以写成函数式组件的形式。\\n\\n函数式组件更简洁，相比于class组件省去了创建实例的损耗，但是每次数据改变都需要进行对比工作，不能像class组件一样使用shouldComponentUpdate避免不必要的对比更新。\\n\\n有了hook API之后，函数式组件也可以维护状态并在特定的声明周期做一些处理了。\\n\"}]}",
      "quizes": ["5", "10", "14"]
    },
    {
      "id": "75",
      "title": "React组件的ShouldComponentUpdate",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "setState",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tgc3uo#rZFEP"
        }
      ],
      "category": "前端编程基础/框架/react/基础用法",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"React组件的ShouldComponentUpdate的作用？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"由于diff工作量比较大，如果setState的值没有改变，其实是不需要进行diff的。如何让state没有改变的时候，不进行diff呢？可以使用shouldComponentUpdate这个生命周期钩子。\\n在调用setState更新数据后，React会判断是否需要进行更新操作，如果没有shouldComponentUpdate这个生命周期钩子，则默认进行对比和更新工作，如果有shouldComponentUpdate，则调用之，如果返回true则更新，返回false则不更新。利用这个钩子，我们可以对新的state和当前的state进行对比，如果有变化，返回true，如果没有变化，返回false。\\n    React.PureComponent实现了浅比较的shouldComponentUpdate，因此我们的组件如果继承了    React.PureComponent就会有了对比state决定是否更新的特性。\\n    但是使用React.PureComponent时候需要注意一个问题，浅比较是比较值是否相同，因此当state中的数据是一个对象，其中属性变化但引用不变、或者state中的数据是一个数组，数组中的元素变化但数组引用不变，这时候比较结果是两者相同，因此不会触发更新。如果希望在对象属性变化、数组元素变化时候触发更新，应该setState时候传入新的对象或数组。\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "76",
      "title": "vue-router中的路由守卫有哪些",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "vue-router导航守卫",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/pkywsg#sLd6v"
        },
        {
          "name": "官网",
          "url": "https://router.vuejs.org/zh/guide/advanced/navigation-guards.html"
        }
      ],
      "category": "前端编程基础/框架/vue/vue-router",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"vue-router中的路由守卫有哪些\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"全局守卫，路由独享守卫和组件内守卫\\n\"}]}",
      "quizes": []
    },
    {
      "id": "77",
      "title": "vuex的使用",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "vuex",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/xos4ss"
        }
      ],
      "category": "前端编程基础/框架/vue/vuex",
      "tags": ["字节", "网易", "快手", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"讲讲vuex的作用和使用。\\nmutation和action的区别？\\ngetters的作用？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态。\\n它主要有以下API\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"1.\"},{\"insert\":\" state\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"2.\"},{\"insert\":\" getters\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"3.\"},{\"insert\":\" mutations\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"4.\"},{\"insert\":\" actions\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"5.\"},{\"insert\":\" module\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"6.\"},{\"insert\":\" 辅助函数：mapState、mapGetters、mapMutations、mapActions\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"7.\"},{\"insert\":\" createStore\\n\\n其中state和getters用来保存状态；mutations和actions用来改变状态；监听状态用的是Vue组件中的computed属性；module是用来组织整个应用的状态管理代码，使状态划分模块，更易于管理；辅助函数用来在监听状态时候简化代码，createStore则用来创建状态管理对象。\\n\\n\\nmutations和actions有区别，mutations不应该用于异步修改状态，因为这样做的话，Vuex是无法知道修改state.count的时机的，因为它是在异步回调里面指定的，因此Vuex无法在调试工具中打印出我们实际改变state的操作。\\n而actions中可以异步更新状态。\\n\\ngetters和state的关系类似于Vue组件data属性和computed属性的关系，getters根据state或者其他getters计算出另一个变量的值，当其依赖的数据变化时候，它也会实时更新。\\n\"}]}",
      "quizes": ["5", "9", "14"]
    },
    {
      "id": "78",
      "title": "v-model的作用",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "v-model",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cc5ehy#Ramyx"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["滴滴"],
      "question": "{\"ops\":[{\"insert\":\"v-model的作用是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"实现双向绑定。\\n\"}]}",
      "quizes": ["", "9"]
    },
    {
      "id": "79",
      "title": "webpack使用",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "初识webpack",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/sq7mtz"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["腾讯", "京东", "美团", "网易"],
      "question": "{\"ops\":[{\"insert\":\"有用过webpack吗？介绍一下对webpack的理解。\\n除了压缩体积，模块打包还有什么作用。\\nchunk是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点链接\\n\"}]}",
      "quizes": ["5", "11"]
    },
    {
      "id": "80",
      "title": "webpack的splitChunks的使用",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "分包加载",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to1m2y#cts92"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"webpack的splitChunks的使用\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点链接\\n\"}]}",
      "quizes": ["5", "11"]
    },
    {
      "id": "81",
      "title": "介绍nodejs stream",
      "type": 1,
      "level": 8,
      "knowledge": [
        {
          "name": "nodejs stream",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/qvlmlc#akOYh"
        }
      ],
      "category": "服务端/node/基础",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"介绍一下nodejs的stream的概念。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"流是一个抽象接口，用在一段一段读取和处理数据的场景，流这个抽象接口被Node中很多对象实现，例如http模块的request、response；fs.createReadStream()等。\\n\\n常用的方法有\\nread // 读入流\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"write // 写入流\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"on // 监听事件\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"pipe // 输出到另一个流\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"\\n常见的事件有\\n\\ndata // 当有数据可读时触发。 \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"end // 没有更多的数据可读时触发。 \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"error // 在接收和写入过程中发生错误时触发。 \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"finish // 所有数据已被写入到底层系统时触发。\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "82",
      "title": "如何用node读取大文件",
      "type": 1,
      "level": 8,
      "knowledge": [
        {
          "name": "nodejs fs api",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/qvlmlc#oHKOf"
        }
      ],
      "category": "服务端/node/基础",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"如何用node读取本地大文件？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"可以使用fs.createReadStream方法创建可读流，或者用第三方模块readline来读取文件。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "83",
      "title": "从输入url到看到界面的过程",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "浏览器原理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9#52bf8648"
        }
      ],
      "category": "浏览器/渲染",
      "tags": ["百度", "阿里", "腾讯", "字节", "美团", "网易", "快手"],
      "question": "{\"ops\":[{\"insert\":\"描述下从输入url到看到界面的过程？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"1.\"},{\"insert\":\" 检查缓存\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"2.\"},{\"insert\":\" DNS解析\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"3.\"},{\"insert\":\" 发送HTTP请求\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"4.\"},{\"insert\":\" 将响应数据提交给渲染进程处理\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"5.\"},{\"insert\":\" 构建DOM\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"6.\"},{\"insert\":\" 样式计算\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"7.\"},{\"insert\":\" 布局\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"8.\"},{\"insert\":\" 分层\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"9.\"},{\"insert\":\" 绘制\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"10.\"},{\"insert\":\" 分块\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"11.\"},{\"insert\":\" 栅格化\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"12.\"},{\"insert\":\" 合成\\n\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "84",
      "title": "http1和http2的区别",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "http2",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ftn3mw#buZsm"
        }
      ],
      "category": "计算机基础/网络/http",
      "tags": ["百度", "阿里", "滴滴", "快手"],
      "question": "{\"ops\":[{\"insert\":\"http1和http2的区别是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"http2为了对http1.1优化，提升性能而生。\\nhttp2相对于http1有以下优化\\n二进制传输\\n头部压缩\\n多路复用\\n服务端推送\\n请求优先级\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "85",
      "title": "http各个版本的改进",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "http各版本介绍",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ftn3mw"
        }
      ],
      "category": "计算机基础/网络/http",
      "tags": ["腾讯", "字节"],
      "question": "{\"ops\":[{\"insert\":\"http各个版本都做了哪些改进\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点链接\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "86",
      "title": "http2.0多路复用",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "http2多路复用",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ftn3mw#rqgRw"
        }
      ],
      "category": "计算机基础/网络/http",
      "tags": ["腾讯"],
      "question": "{\"ops\":[{\"insert\":\"http2.0多路复用的底层实现是什么样的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"使用http/2的话，同一个TCP连接中可能有多个流。多个流之间是无序的。每个请求或者响应都被赋予一个流id，每个帧的数据包里面带有流id，标识这个帧属于那个流。这样就可以让多个流复用同一个TCP连接了。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "87",
      "title": "http2.0多路复用",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "http2多路复用",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ftn3mw#rqgRw"
        }
      ],
      "category": "计算机基础/网络/http",
      "tags": ["腾讯"],
      "question": "{\"ops\":[{\"insert\":\"http2.0多路复用的底层实现是什么样的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"使用http/2的话，同一个TCP连接中可能有多个流。多个流之间是无序的。每个请求或者响应都被赋予一个流id，每个帧的数据包里面带有流id，标识这个帧属于那个流。这样就可以让多个流复用同一个TCP连接了。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "88",
      "title": "同一个域名并发请求数量",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "http2多路复用",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ftn3mw#rqgRw"
        }
      ],
      "category": "计算机基础/网络/http",
      "tags": ["腾讯"],
      "question": "{\"ops\":[{\"insert\":\"同一个域名并发请求数量\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"chrome在http1.1是6个，http2没有限制。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "89",
      "title": "https的通信过程",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "https",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/wl6fa4#44c71c37"
        }
      ],
      "category": "计算机基础/网络/https",
      "tags": ["百度", "阿里", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"https的通信过程是怎样的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"1.\"},{\"insert\":\" 约定非对称加密算法及hash算法\\n①客户端→服务器\\n客户端将自己支持的一套加密规则（包括对称加密算法和hash算法）发送给服务器\\n②服务器→客户端\\n选定对称加密和hash算法\\n服务器将选定的算法和公钥发送给客户端\\n\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"2.\"},{\"insert\":\" 传递非对称加密秘钥\\n③客户端→服务器\\n生成随机数秘钥（对称加密秘钥），并用公钥加密，得到加密后的随机数\\n计算握手消息\\n用随机数对握手消息加密，得到加密后的握手消息\\n用约定好的hash算法计算握手消息，得到hash后的握手消息\\n客户端将加密后的随机数、加密后的握手消息、hash后的握手消息发送到服务器\\n④服务器→客户端\\n用私钥解密随机数\\n用随机数解密握手消息\\n验证hash后的握手消息与客户端发来的hash是否一致\\n用随机数加密一段握手消息\\n用hash加密握手消息\\n服务器将加密后的握手消息和hash后的握手消息发送给客户端\\n⑤客户端→服务器\\n客户端解密握手消息并验证hash一致\\n客户端用随机数加密握手消息\\n用hash加密握手消息\\n客户端将加密后的握手消息和hash后的握手消息发送给服务器\\n握手结束，客户端开始向服务器发送通信信息（使用随机数进行通信）\\n\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "90",
      "title": "https证书原理",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "https证书",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/wl6fa4#d40b5115"
        }
      ],
      "category": "计算机基础/网络/https",
      "tags": ["快手"],
      "question": "{\"ops\":[{\"insert\":\"介绍下https证书原理\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"由于私钥加密的密文只有公钥可以解密，假设客户端有某个服务器的公钥，那么如果加密的信息能够使用公钥解密，说明这条信息是由该服务器发出的。\\n\\n客户端如何保证自己拿到的服务器的公钥就是这个服务器的公钥，而不是攻击者盗用的公钥呢？\\n\\n这一点通过权威的第三方证明来保证，就像淘宝平台如何解决买家对卖家的信任问题？答案是借助淘宝这个权威第三方平台。服务器需要向证书的颁发机构申请证书，通过证书来证明自己的身份，这就是ssl证书的作用，下面简称证书。\\n\\n证书提供了公钥-私钥对，和域名与公钥绑定关系的证明。\\n\\n服务器安装了证书后，就可以证明自己的身份了，在https通信时，客户端接收到服务器发送的证书后会去验证证书的绑定域名是否与当前访问域名一致，一致则可以确认网站身份。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "91",
      "title": "https与http的关系和区别",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "https与http",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/wl6fa4#YscX1"
        }
      ],
      "category": "计算机基础/网络/https",
      "tags": ["百度", "阿里", "美团", "滴滴", "快手", "网易"],
      "question": "{\"ops\":[{\"insert\":\"https与http的关系和区别是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"https是一个基于http的保密通信协议，它在http基础上增加了一个安全套接层，https由于需要在通信过程中进行加密解密，因此性能低于http，当然安全性高于http。在https网页中发送http的ajax请求将会被浏览器block，因为浏览器认为这是不安全的操作，而在http网页中发送https请求是被允许的。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "92",
      "title": "https为什么是安全的",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "为什么需要https",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/wl6fa4#hU1zH"
        }
      ],
      "category": "计算机基础/网络/https",
      "tags": ["腾讯"],
      "question": "{\"ops\":[{\"insert\":\"https为什么是安全的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"https保证数据以更保密的方式传输，并增加对服务器身份验证，这可以使我们的数据传输更安全，有效防止数据的泄露和篡改。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "93",
      "title": "二分查找",
      "type": 2,
      "level": 12,
      "knowledge": [
        {
          "name": "二分查找",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dokn6w#0ac6e5c6"
        }
      ],
      "category": "计算机基础/数据结构与算法",
      "tags": ["百度", "快手"],
      "question": "{\"ops\":[{\"insert\":\"实现一个二分查找方法\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"/** \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\" * 二分查找 \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\" * 假设数组是升序排序 \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\" */  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function search(arr, item, left, right) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    if (left > right) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        return -1;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var mid = Math.floor((left + right) / 2);  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    if (arr[mid] === item) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        return mid;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    else {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        if (arr[mid] > item) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            return search(arr, item, left, mid - 1);  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        else {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            return search(arr, item, mid + 1, right);  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function bSearch(arr, item) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return search(arr, item, 0, arr.length - 1);  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "94",
      "title": "快排",
      "type": 2,
      "level": 14,
      "knowledge": [
        {
          "name": "快排",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dokn6w#RKnJ9"
        }
      ],
      "category": "计算机基础/数据结构与算法",
      "tags": ["百度", "阿里", "字节", "拼多多", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"快排时间复杂度？如何实现？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"思路是：我们假设是升序排序。快速排序使用了双指针的思想，其基本思想是首先选取一个分隔数，然后两个游标从两侧对向移动，左边游标向右游走，直到遇到大于分隔数的元素停止，右边游标则是向左游走，直到遇到小于等于分隔数的元素则停止，然后交换两个游标指向的元素，然后继续游走。这样操作保证了游走结束时，左边的元素都小于等于分隔数，右边的元素都大于分隔数。这样就完成了一次分隔。然后递归地把分隔点左边的序列和右边的序列进行分隔。最终可以得到升序序列。\\n时间复杂度是O(nlg(n))\\n/** \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\" * 快排\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\" */  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function partition(arr, left, right) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var temp;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var i = left, j = right;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var pivot = arr[left];  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var result;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    while (i < j) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        // i <= j而不是i < j这样才可以保证i-1位置上的元素满足arr[i] <= pivot  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        // 且是从左至右最后一个满足这个条件的元素  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        while (arr[i] <= pivot && i <= j) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            i++;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        while (arr[j] > pivot && j >= i) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            j--;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        if (i < j) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            temp = arr[i];  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            arr[i] = arr[j];  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            arr[j] = temp;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    result = i - 1;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    // 将分隔数移到分隔点  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    if (result !== left) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        temp = arr[left];  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        arr[left] = arr[result];  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        arr[result] = temp;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return result;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function quickSort(arr, left, right) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    if (left >= right) {  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        return;  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var flag = partition(arr, left, right);  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    quickSort(arr, left, flag - 1);  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    quickSort(arr, flag + 1, right);  \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "95",
      "title": "排序算法的时间和空间复杂度",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "排序算法",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tm3gdg#c360e994"
        }
      ],
      "category": "计算机基础/数据结构与算法",
      "tags": ["腾讯", "美团"],
      "question": "{\"ops\":[{\"insert\":\"说出你知道的排序算法及其时间和空间复杂度\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "96",
      "title": "前端性能优化方法",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "前端性能优化小结",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9#cd5294f9"
        }
      ],
      "category": "性能优化",
      "tags": ["百度", "阿里", "腾讯", "字节", "滴滴", "拼多多", "快手"],
      "question": "{\"ops\":[{\"insert\":\"前端性能如何优化？\\n你们项目中是怎么做优化的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"页面展示可以分为3个阶段，请求页面，加载和解析页面，渲染。\\n（主要优化方法请参考知识点链接）\\n1、请求数据阶段主要指标是服务器响应时间，从服务器角度优化。\\n2、加载和解析页面阶段，性能优化的主要思路是减少请求数量、降低资源的大小和避免阻塞。\\n3、渲染阶段优化思路是避免重绘和重排。\\n\"}]}",
      "quizes": ["", "14"]
    },
    {
      "id": "97",
      "title": "白屏和首屏时间",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "性能指标",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9#7e687515"
        }
      ],
      "category": "性能优化",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"如何计算白屏和首屏时间？onload事件发生了什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"白屏结束时间 = FP事件触发时间\\n首屏结束时间 = FCP事件触发时间\\n\\nFP（First Paint）表示渲染出第一个像素点的时间。FP一般在HTML解析完成或者解析一部分时候触发。\\nFCP（First Contentful Paint）表示渲染出第一个内容的时间，这里的“内容”可以是文本、图片、canvas。\\nOnload Event，它代表页面中依赖的所有资源：DOM、图片、CSS、Flash等都加载完。\\n\\n指标计算方法\\n// FP\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const fp = performance.getEntries('paint').filter(entry => entry.name == 'first-paint')[0].startTime;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// FCP\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const fcp = performance.getEntries('paint').filter(entry => entry.name == 'first-contentful-paint')[0].startTime;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// Onload Event\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const l = performance.timing.loadEventEnd - performance.timing.navigationStart;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "12"]
    },
    {
      "id": "98",
      "title": "浏览器渲染过程",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "浏览器渲染过程",
          "url": "https://leetcode-cn.com/circle/discuss/DbsYBi/"
        }
      ],
      "category": "性能优化",
      "tags": ["阿里", "腾讯"],
      "question": "{\"ops\":[{\"insert\":\"浏览器渲染过程是什么样的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"1.\"},{\"insert\":\" html转成dom\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"2.\"},{\"insert\":\" 计算style\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"3.\"},{\"insert\":\" 生成布局树\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"4.\"},{\"insert\":\" 分层，生成分层树\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"5.\"},{\"insert\":\" 主线程给每个图层生成绘制列表，交给合成线程处理\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"6.\"},{\"insert\":\" 合成线程将图层分块\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"7.\"},{\"insert\":\" 合成线程在光栅化线程池中将图块转成位图\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"8.\"},{\"insert\":\" 合成线程发送绘制图块的命令drawquad给浏览器进程\\n\"},{\"attributes\":{\"color\":\"#6796e6\"},\"insert\":\"9.\"},{\"insert\":\" 浏览器根据命令绘制，并显示在显示器上\\n\"}]}",
      "quizes": ["5", "12"]
    },
    {
      "id": "99",
      "title": "js动画的性能问题",
      "type": 1,
      "level": 12,
      "knowledge": [],
      "category": "性能优化",
      "tags": ["阿里"],
      "question": "{\"ops\":[{\"insert\":\"js动画为什么会有性能问题？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"因为js动画修改了style会导致重排，重排触发重新计算布局树并且生成分层树，造成性能损耗。\\n\"}]}",
      "quizes": ["5", "12"]
    },
    {
      "id": "100",
      "title": "setTimeout和requestAnimationFrame的区别",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "requestAnimationFrame",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/mxwm92#c5Pes"
        }
      ],
      "category": "性能优化",
      "tags": ["阿里"],
      "question": "{\"ops\":[{\"insert\":\"setTimeout和requestAnimationFrame的区别是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"通常我们可以通过定时器（setTimeout/setInterval）实现一个动画，但是定时器时间并不精确，如果时间太短，那么可能造成多余的操作，消耗CPU，如果时间长，就会导致动画不流畅。另外当画面不展示时候，定时器依然执行，导致不必要的CPU资源消耗，耗电更快。\\n\"}]}",
      "quizes": ["5", "12"]
    },
    {
      "id": "101",
      "title": "什么会阻塞dom渲染",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "渲染过程",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9#qTHYu"
        }
      ],
      "category": "性能优化",
      "tags": ["阿里", "网易"],
      "question": "{\"ops\":[{\"insert\":\"什么情况下会阻塞DOM渲染？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"1. css解析会阻塞渲染。因为构造渲染树需要CSSOM，因此CSS解析完成是后续工作的先决条件。 \\n2. css下载会阻塞js执行，不会阻塞html解析。 \\n3. js下载和执行会阻塞html。 \\n4. 在执行 JavaScript 脚本之前，会先加载并解析页面中的CSS样式（包括link标签和style标签）（如果存在）。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。\\n\"}]}",
      "quizes": ["5", "12"]
    },
    {
      "id": "102",
      "title": "script标签什么情况不阻塞渲染",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "渲染过程",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9#qTHYu"
        }
      ],
      "category": "性能优化",
      "tags": ["腾讯", "滴滴", "快手"],
      "question": "{\"ops\":[{\"insert\":\"script标签什么情况不阻塞渲染？\\n它为什么会有这三种模式？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"async、defer和动态创建标签。\\n可以让script异步加载避免阻塞dom渲染，提升首屏渲染速度。\\n\"}]}",
      "quizes": ["5", "12"]
    },
    {
      "id": "103",
      "title": "网络攻击有哪些",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "web安全",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tuzfxd"
        }
      ],
      "category": "安全",
      "tags": ["百度", "阿里", "腾讯", "字节"],
      "question": "{\"ops\":[{\"insert\":\"网络攻击有哪些？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"主要有xss（跨站脚本攻击）、csrf（跨站请求伪造）、sql注入等。具体的原理、防御和其他攻击请见知识点。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "104",
      "title": "代码执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [
        {
          "name": "js数据类型转换规则",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#iS35D"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["滴滴"],
      "question": "{\"ops\":[{\"insert\":\"const o1 = {};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const o2 = {};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(o1 == o2);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(o1 === o2);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"都是false，因为对象是引用类型，只有指向同一个对象时候才能相等。\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "105",
      "title": "代码执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [
        {
          "name": "js数据类型转换规则",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#iS35"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["美团"],
      "question": "{\"ops\":[{\"insert\":\"[] + []\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"[] + ![]\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"[] == ![]\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"[] == []\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"1. 结果是 ''，空字符串，因为数组是对象类型，先转为字符串在进行加法运算\\n2. 结果是 'false'，因为这个表达式等同于[] + false，对象转为字符串即'' + false\\n3. 结果是true，这个相对复杂，首先这个表达式等同于[] == false，然后布尔转为数字：[] == 0，然后对象要转为字符串再比较，即：'' == 0，这样是一个字符串和一个数值比较，要先将字符串转为数字，即：0 == 0\\n4. 是false，因为不是同一个对象的引用\\n\"}]}",
      "quizes": ["8"]
    },
    {
      "id": "106",
      "title": "代码执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [
        {
          "name": "js数据类型转换规则",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#iS35D"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["滴滴"],
      "question": "{\"ops\":[{\"insert\":\"null == 0\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"null > 0\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"null < 0\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"null >= 0\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"null <= 0\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"null == 0是false，因为null只和自己或者undefined相等，其他都是false\\nnull和0进行大小比较时候，因为0是数值类型，因此将null也转为数值进行比较，所以\\nnull > 0和null < 0为false，而null >= 0和null <= 0为true。\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "107",
      "title": "代码执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [
        {
          "name": "值类型和引用类型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#YFdbY"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["滴滴"],
      "question": "{\"ops\":[{\"insert\":\"let num = 10;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function ch(num) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    num = 12;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"ch(num);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(num);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\\n\"},{\"insert\":\"let obj = {};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function ch1(obj) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    obj.a = 'a';\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"ch1(obj);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(obj.a);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"num打印结果是10，因为num是值类型，在ch函数作用域内是临时变量，不会影响传入的实参。\\n\\nobj1.a打印结果是'a'，因为obj是引用类型，传入ch1中obj指向外部的obj数据，因此函数内的代码直接改变了obj的属性。\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "108",
      "title": "如何创建一个对象",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "构造函数和对象",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tf43ma#rjdz0"
        }
      ],
      "category": "前端编程基础/js/面向对象",
      "tags": ["网易"],
      "question": "{\"ops\":[{\"insert\":\"js如何创建一个对象？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"使用对象字面量或者Object构造函数\\nconst a = {};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const b = new Object();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "109",
      "title": "js基本数据类型和引用数据类型",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "值类型和引用类型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#YFdbY"
        },
        {
          "name": "判断类型的方法",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#OMba9"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["百度", "美团", "滴滴", "拼多多", "京东"],
      "question": "{\"ops\":[{\"insert\":\"说一下 js 中的基本数据类型和引用数据类型都有哪些？其区别是什么？\\n\\n有哪些判断类型的方法？\\n\\n如何使用toString()判断数据类型？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"基本类型包括number、string、boolean、undefined，引用类型包括Function和Object。区别是值类型和引用类型的区别是，值类型赋的变量直接存储数据，引用类型的变量存储数据的引用。\\n\\n判断类型方法有\\n1. typeof\\n2. constructor\\n3. instanceof\\n4. Object.prototype.toString.call()\\n\\n请参考知识点链接\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "110",
      "title": "类型判断",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "判断类型的方法",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#OMba9"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["网易"],
      "question": "{\"ops\":[{\"insert\":\"typeof判断哪个类型会出错？\\n\\nObject.prototype.toString.call()判断哪个类型会出错？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"typeof判断null和数组会出错\\nObject.prototype.toString.call()判断自定义对象只能得到\\\"[object Object]\\\"的结果，所以如果需要判断构造函数可以结合instanceof或者constructor来使用\\n\"}]}",
      "quizes": ["5", "8", "14"]
    },
    {
      "id": "111",
      "title": "typeof能判断函数和null吗",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "判断类型的方法",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#OMba9"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"typeof能判断函数吗？能判断null吗？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"可以判断函数，不能判断null\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "112",
      "title": "如何判断一个对象为空",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "判断对象是否为空",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#eMUd2"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"如何判断一个对象为空？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"// 方法1  注意该方法性能较差\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function isEmptyObject(obj) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return JSON.stringify(obj) === '{}';\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// 方法2  判断是否含有私有属性\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function isEmptyObject(obj) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  for (var key in obj) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    if (obj.hasOwnProperty(key)) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"      return false;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return true;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// 方法3 Object.keys也是只能获取自身属性，不能获取原型属性\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function isEmptyObject(obj) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return Object.keys(obj).length === 0;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "113",
      "title": "typeof和instanceof的区别",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "判断类型的方法",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl#OMba9"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["百度", "腾讯", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"typeof和instanceof的区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"typeof和instanceof都是js中用来判断数据类型的方法\\ntypeof适用于判断数据基本类型的场景，instanceof用来判断对象（包括内置对象和自定义对象）所对应的类的场景\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "114",
      "title": "null和undefined的区别",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "null和undefined的区别",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/aizgpl/edit#PGaKt"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["阿里", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"null和undefined有什么区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"本身都表示“没有”，但null表示引用类型的对象为空，undefined则表示变量未定义。\\n在相等判断时候，null和undefined是相等的\\n但null和undefined在很多方面有区别。\\n含义不同\\nnull表示对象空指针，undefined表示变量未定义。\\n类型不同\\ntypeof null // 'object'\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"typeof undefined // 'undefined'\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"Number(null) // 0\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"Number(undefined) // NaN\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"\\n应用场景不同\\nnull：\\n作为对象原型链的终点 \\nundefined：\\n定义了变量，没有初始化，默认是undefined\\n函数不return，或者return后面没有值，则函数默认返回undefined\\n函数参数如果不传，默认是undefined\\n\"}]}",
      "quizes": ["5", "8", "14"]
    },
    {
      "id": "115",
      "title": "0.1 + 0.2 != 0.3原因",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "为什么0.1+0.2不等于0.3",
          "url": "https://zhuanlan.zhihu.com/p/87672024"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"0.1 + 0.2 != 0.3原因是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"JavaScript对于小数数据使用双精度存储，10进制的小数转为二进制时候会损失一部分精度，因此再进行运算的话结果会不准确。\\n10进制的小数转二进制的方法是按位乘2并保留整数部分，由于双精度是按53存储，如果超过这个长度会四舍五入。\\n浮点数值计算会产生误差是基于IEEE754数值的浮点计算的通病，ECMAScript并非独此一家。\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "116",
      "title": "number的最大值",
      "type": 1,
      "level": 14,
      "knowledge": [],
      "category": "前端编程基础/js/数据类型",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"number类型最大值是多少？如果后台发的数据超过这个值怎么办？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"大多数浏览器最大值是2^53，最小是-2^53。最大值和最小值可以通过Number.MAX_VALUE和Number.MIN_VALUE查看。\\n后台发送数据超过这个值可以用字符串类型代替。\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "117",
      "title": "12和12.0有什么区别？",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "《JavaScript高级程序设计》",
          "url": "https://book.douban.com/subject/35175321/"
        }
      ],
      "category": "前端编程基础/js/数据类型",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"12和12.0有什么区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"没有区别，因为整型值存储空间是浮点类型的一半，所以js会把12.0转为12存储。\\n\"}]}",
      "quizes": ["5", "8"]
    },
    {
      "id": "118",
      "title": "代码的执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [],
      "category": "前端编程基础/js/this",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"function Foo() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  getName = function () {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    console.log(1)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  console.log('this is ' + this)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  return this\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"Foo.getName = function () {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  console.log(2)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"Foo.prototype.getName = function () {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  console.log(3)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var getName = function () {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  console.log(4)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function getName () {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  console.log(5)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"Foo.getName();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"getName();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"Foo().getName();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"getName();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"new Foo.getName();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"new Foo().getName();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"new new Foo().getName();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Foo.getName(); // 2\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"getName(); // 4\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"Foo().getName(); // this is [object Window], 1\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"getName();  // 1\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"new Foo.getName(); // 2\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"new Foo().getName(); // this is [object Object], 3\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"new new Foo().getName(); // this is [object Object], 3\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"\\n整段代码分为声明和执行两部分。\\n首先声明了一个类Foo，并给Foo添加了一个静态方法getName和一个原型方法getName\\n然后有一个函数表达式getName和一个函数声明getName，js会先将函数声明提升，然后执行函数表达式，覆盖了函数声明，因此全局作用域的getName会打印4。\\n接下来看执行部分。\\nFoo.getName() 调用Foo的静态方法，因此打印2。\\ngetName() 调用了全局作用域的getName方法，因此打印4。\\nFoo().getName() 在全局作用域调用Foo，因此Foo内的this指向window，Foo内执行getName = function () {console.log(1)}，覆盖了全局作用域的getName方法，因此全局作用域的getName会打印1了。调用Foo()打印this is [object Window]，由于Foo返回的this指向window，因此getName是window.getName，即全局的getName，打印1。\\ngetName() 再次调用时候已经被上面Foo内部的代码覆盖，因此打印1。\\nnew Foo.getName() 将Foo作为一个构造函数，使用new调用，会创建一个对象并返回，因此打印this is [object Object]，然后调用这个实例的getName()，就是Foo的原型方法，因此打印3。\\nnew new Foo().getName() 和上一句原理相同。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "119",
      "title": "代码的执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [],
      "category": "前端编程基础/js/this",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"window.name = 'ByteDance';\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function A () {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  this.name = 123;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"A.prototype.getA = function(){\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  console.log(this);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  return this.name + 1;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"let a = new A();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"let funcA = a.getA;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"funcA();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"打印结果是 'ByteDance1'\\n因为a.getA指向A的原型方法，然后赋值给funcA，接下来funcA调用时候在全局作用域，因此funcA内部的this指向window。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "120",
      "title": "代码的执行结果",
      "type": 4,
      "level": 6,
      "knowledge": [],
      "category": "前端编程基础/js/this",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"说出代码的执行结果？如果只改最后一行怎么让它也能输出aaa？\\nvar obj = { \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  name: 'aaa',\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  getName: function() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"      console.log(this.name);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var get = obj.getName;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"obj.getName();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"get();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"obj.getName() 通过obj调用，因此getName内部this指向obj，所以打印'aaa'。\\nget() 因为在全局调用，因此this指向window，所以打印''。\\n可以使用apply或者call改变get指向：get.call(obj);或者get.apply(obj);\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "121",
      "title": "代码的执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [
        {
          "name": "js的this指向之箭头函数",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ruk1qu#frN7I"
        },
        {
          "name": "箭头函数的词法作用域",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#elztK"
        }
      ],
      "category": "前端编程基础/js/this",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"var name = 'win';\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const obj = {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    name: 'obj',\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    a: () => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        console.log(this.name);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const obj1 = {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    name: 'obj1'\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"obj.a.call(obj1);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"结果是打印'win'。\\n因为箭头函数声明时候所在的作用域是全局，因此指向window，call并不能改变箭头函数指向。\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "122",
      "title": "代码执行结果",
      "type": 4,
      "level": 12,
      "knowledge": [
        {
          "name": "async/await",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca#XtEg"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"function fn() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  return new Promise((resolve, reject) => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"      setTimeout(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"          reject('error');\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"      }, 1000);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  });\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const foo = async () => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"   try {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"     await fn();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  } catch (e) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"      console.log('lala', e);  // some error\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"foo();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"打印 lala error。\\n如果await后面返回的promise reject掉，需要用try catch语句捕获这个reject。\\n\"}]}",
      "quizes": ["5", "6"]
    },
    {
      "id": "123",
      "title": "循环打印数字",
      "type": 4,
      "level": 14,
      "knowledge": [
        {
          "name": "循环打印数字",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#YFTGZ"
        }
      ],
      "category": "前端编程基础/js/作用域",
      "tags": ["快手", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"for (var i = 0; i < 3; i++) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    document.body.addEventListener(\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        'click',\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        function() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            console.log(i);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    )\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"\\n上面代码输出什么？\\n如果想0 1 2，怎么做？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"使用let\\nfor (let i = 0; i < 3; i++) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    document.body.addEventListener(\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        'click',\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        function() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            console.log(i);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    )\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["7"]
    },
    {
      "id": "124",
      "title": "代码执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [
        {
          "name": "词法作用域和动态作用域",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#elztK"
        }
      ],
      "category": "前端编程基础/js/作用域",
      "tags": ["快手"],
      "question": "{\"ops\":[{\"insert\":\"var count = 10;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function a() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\" return count + 10;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function b() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\" var count = 20;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\" return a();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(b());\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"结果是20\\n因为js是词法作用域，a方法中的count在声明时候，外层是全局，即10，因此+10之后结果是20。\\n\"}]}",
      "quizes": ["5", "7"]
    },
    {
      "id": "125",
      "title": "说出代码执行结果",
      "type": 4,
      "level": 6,
      "knowledge": [
        {
          "name": "作用域和变量提升",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0bl"
        },
        {
          "name": "let和const",
          "url": "https://es6.ruanyifeng.com/#docs/let"
        }
      ],
      "category": "前端编程基础/js/作用域",
      "tags": ["字节", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"// 代码段1\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(a);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"a = 1;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// 代码段2\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(b);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var b = 2; \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// 代码段3\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var c = 1;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"let c;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(c);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"代码段1，没有变量声明，因此报错。\\n代码段2，因为存在变量提升，因此打印undefined。\\n代码段3，let声明不能有重复声明，因此报错。\\n\"}]}",
      "quizes": ["5", "7"]
    },
    {
      "id": "126",
      "title": "说出代码执行结果",
      "type": 4,
      "level": 6,
      "knowledge": [
        {
          "name": "js作用域",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#tYUhx"
        }
      ],
      "category": "前端编程基础/js/作用域",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"// 1\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var a = 10;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function b() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    a = 100;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"b();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(a);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\" \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"// 2\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var a = 10;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function b() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    a = 100;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    function a() {};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"b();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(a);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\" \"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"// 3\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var a = 10;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function b() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var a = 100;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"b();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(a);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"// 4\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var resource = ['a.png', 'b.png', 'c.png', 'd.png', 'e.png', 'f.png'];\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"for(var i = 0; i < resource.length; i++) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    var img = new Image();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    img.src = resource[i];\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    img.onload = funtion(){\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        console.log(i);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"1. 打印100，因为b方法中的a沿着作用域链查找到外层定义的a，修改了之后就变成100了。\\n2. 打印10，因为b方法中定义的function a() {}提升到函数顶部，所以b中的a就是这个定义的函数，修改这个a不会影响到外部的变量a。\\n3. 打印10，和2类似，b方法中已经声明并初始化了变量a，因此对其的修改是在b内部，不影响外面的变量a。\\n4. 如果img都能正常加载，则打印6个6。\\n\"}]}",
      "quizes": ["5", "7"]
    },
    {
      "id": "127",
      "title": "函数表达式和函数声明有什么区别",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "变量提升",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#WIKYO"
        }
      ],
      "category": "前端编程基础/js/作用域",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"函数表达式和函数声明有什么区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"函数声明会提升，函数表达式则不会，因此函数声明之前可以正常调用，但函数表达式之前调用函数则会报错。\\n\"}]}",
      "quizes": ["5", "7"]
    },
    {
      "id": "128",
      "title": "代码执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [
        {
          "name": "原型链",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tf43ma#gdv48"
        }
      ],
      "category": "前端编程基础/js/面向对象",
      "tags": ["快手"],
      "question": "{\"ops\":[{\"insert\":\"Function.prototype.a = () => console.log(1);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"Object.prototype.b = () => console.log(2);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"function A() {};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var a = new A();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"a.a();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"a.b();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"a.a(); 报错，因为沿着原型链找不到a方法。\\na.b(); 打印2，因为任何一个构造函数都是Object的实例。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "129",
      "title": "代码执行结果",
      "type": 4,
      "level": 14,
      "knowledge": [
        {
          "name": "js面向对象",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tf43ma#vgiU9"
        }
      ],
      "category": "前端编程基础/js/面向对象",
      "tags": ["快手"],
      "question": "{\"ops\":[{\"insert\":\"function Foo() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    this.a = 1;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        a: 4,\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        b: 5\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    };\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"Foo.prototype.a = 6;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"Foo.prototype.b = 7;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"Foo.prototype.c = 8;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"var o = new Foo();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(o.a);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(o.b);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"console.log(o.c);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"构造函数return一个对象，因此使用new调用构造函数就返回这个对象，这个对象的构造函数是Object。\\n因此打印4,5,undefined。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "130",
      "title": "移动端自适应",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "移动端自适应简介",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lgp0rl"
        }
      ],
      "category": "前端编程基础/css/自适应",
      "tags": ["网易", "阿里", "腾讯", "美团", "快手"],
      "question": "{\"ops\":[{\"insert\":\"如何实现移动端自适应？\\nflexible.js 原理？\\n那种方案比较好？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"两种方案rem自适应和vm自适应\\nflexible.js实现了rem自适应\\nflexible.js动态修改了name为\\\"viewport\\\"的meta标签中的width为device-width，让页面宽度为视口宽度，然后根据屏幕宽度设置了html的fontSize（比例为 1 / 10）。这样就可以使用rem单位来实现自适应了。\\nflexible.js除了实现rem自适应，还通过动态修改scale实现了发丝线的功能。\\nvm自适应方案代码侵入性小，不需要依赖脚本，并且目前兼容性已经不错，所以vm方案更好。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "131",
      "title": "new一个对象发生了什么",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "new的原理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tf43ma#KNmyY"
        }
      ],
      "category": "前端编程基础/js/面向对象",
      "tags": ["字节", "快手", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"new一个对象发生了什么（构造函数的执行过程？）\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"1. 创建了一个空的js对象（即{}）\\n2. 将空对象的原型prototype指向构造函数的原型\\n3. 将空对象作为构造函数的上下文（改变this指向）\\n4. 判断构造函数的返回值，以决定最终返回的结果。\\n  a. 如果返回值是基础数据类型，则忽略返回值；\\n  b. 如果返回值是引用数据类型，则使用return 的返回，也就是new操作符无效；\\n\"}]}",
      "quizes": ["5", "14"]
    },
    {
      "id": "132",
      "title": "讲一下变量提升",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "变量提升",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#WIKYO"
        }
      ],
      "category": "前端编程基础/js/作用域",
      "tags": ["字节", "京东"],
      "question": "{\"ops\":[{\"insert\":\"讲一下变量提升（js预编译），为什么会有变量提升？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"javaScript在执行之前会先进行预编译，主要做两个工作：\\n1. 将全局作用域或者函数作用域内所有函数声明提前。\\n2. 将全局作用域或者函数作用域内所有var声明的变量提前声明，并赋值为undefined。\\n这就是变量提升。\\n\"}]}",
      "quizes": ["5", "7"]
    },
    {
      "id": "133",
      "title": "实现每隔一秒输出数组中的一个数字",
      "type": 3,
      "level": 14,
      "knowledge": [
        {
          "name": "循环打印数字",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gu0blp#YFTGZ"
        }
      ],
      "category": "前端编程基础/js/作用域",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"实现每隔一秒输出数组中的一个数字\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"使用闭包或者let\\nfunction log1(arr) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    for(var i = 0; i < arr.length; i++) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        setTimeout((function(num) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            return function() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"                    console.log(num);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        })(i), 100);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"function log2(arr) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    for（let i = 0; i < arr.length; i++）{\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        setTimeout(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            if (i < arr.length){\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"                console.log(arr[i])\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        }, 1000);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "7"]
    },
    {
      "id": "134",
      "title": "手写promise",
      "type": 3,
      "level": 12,
      "knowledge": [
        {
          "name": "实现Promise",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca#PPnZE"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["百度", "拼多多", "京东"],
      "question": "{\"ops\":[{\"insert\":\"手写promise\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点\\n\"}]}",
      "quizes": ["5", "6", "14"]
    },
    {
      "id": "135",
      "title": "实现Promise.all，Promise.race，Promise.any",
      "type": 3,
      "level": 12,
      "knowledge": [
        {
          "name": "实现Promise.all、Promise.race、Promise.any",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca#m4WL0"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["百度", "滴滴", "网易"],
      "question": "{\"ops\":[{\"insert\":\"如何实现Promise.all、Promise.race和Promise.any方法。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点\\n\"}]}",
      "quizes": ["5", "6", "14"]
    },
    {
      "id": "136",
      "title": "Promise.all，Promise.race区别",
      "type": 3,
      "level": 12,
      "knowledge": [
        {
          "name": "实现Promise.all、Promise.race、Promise.any",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca#m4WL0"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"Promise.all，Promise.race区别是什么？\\n手写一个方法，使用Promise.all，实现所有都resolved/reject时才返回，并返回所有的结果\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"区别是：\\nPromise.all()  全部promise成功才算成功，一个promise就算失败，成功的话，返回成功的数据数组，失败的话抛出最先失败的promise的reason。\\nPromise.race()  最先的promise完成则返回，promise结果和最先完成的promise一致。\\n手写方法：\\nfunction allComplete(arr) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return Promise.all(arr.map(promise => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        return new Promise(\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            resolve => promise.then(resolve, resolve)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        );\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }));\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "6"]
    },
    {
      "id": "137",
      "title": "promise的catch后面跟一个then会怎么执行",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "promise.catch",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to8pca/edit#hXCAj"
        }
      ],
      "category": "前端编程基础/js/promise",
      "tags": ["美团"],
      "question": "{\"ops\":[{\"insert\":\"promise的catch后面跟一个then会怎么执行？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"catch方法和then方法的reject回调用法相同，因此后面的then怎么执行取决于catch的返回结果。\\n\"}]}",
      "quizes": ["5", "6"]
    },
    {
      "id": "138",
      "title": "callback改成promise",
      "type": 3,
      "level": 12,
      "knowledge": [],
      "category": "前端编程基础/js/promise",
      "tags": ["美团"],
      "question": "{\"ops\":[{\"insert\":\"将接受callback参数的方法改成promise形式\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"function promisify(fn) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    return function() {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        const args = arguments;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        return new Promise((resolve, reject) => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            fn(...args, (err, data) => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"                if (err) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"                    reject(err)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"                }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"                else {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"                    resolve(data)\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"                }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"            })\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        });\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"function test(digit, callback) {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    setTimeout(() => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"        callback(null, digit + 1);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"    }, 100);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"test(1, console.log);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\\n\"},{\"insert\":\"const promiseTest = promisify(test);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"promiseTest(1).then(console.log, console.error);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "6"]
    },
    {
      "id": "139",
      "title": "vue框架原理",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "Vue框架原理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lyy3tr"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["阿里", "字节", "网易"],
      "question": "{\"ops\":[{\"insert\":\"讲一下vue框架的原理？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"我们使用Vue开发应用，实际上是编写若干Vue组件，实现模板、data、生命周期钩子等，然后执行new Vue()，将根组件挂载到指定的DOM节点上面，当我们编写的组件中生命周期钩子里面的或者在模板的元素事件中改变数据时候，视图会响应地更新。这样就实现了应用。\\n那么Vue是如何实现上面的效果的呢？\\nnew Vue()之后，Vue会从根组件开始，遍历整个组件树，对每个组件进行处理。\\n对于一个Vue组件，Vue首先会进行模板编译，将模板编译为render函数，render函数返回虚拟DOM，如果遇到子组件，也对子组件做同样操作，最终形成一个虚拟DOM树。\\nVue会把虚拟DOM映射到真实DOM并渲染到指定节点上，这样就实现了视图的渲染。\\nVue在组件初始化时候还会设置数据为响应式，并将依赖于数据的渲染方法、computed、watch收集起来。\\n当数据改变后，Vue会根据初始化时候收集的依赖，更新视图，这时候我们就看到最新的界面了。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "140",
      "title": "vue常用指令",
      "type": 1,
      "level": 6,
      "knowledge": [
        {
          "name": "Vue指令",
          "url": "https://cn.vuejs.org/v2/api/#%E6%8C%87%E4%BB%A4"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"vue常用指令有哪些？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"v-show\\nv-if、v-else-if、v-else\\nv-for\\nv-bind\\nv-model\\nv-on\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "141",
      "title": "Vue3和Vue2的区别",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "迁移构建版本",
          "url": "https://v3.cn.vuejs.org/guide/migration/introduction.html#%E8%BF%81%E7%A7%BB%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["腾讯", "网易", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"vue3.0有哪些变化？Vue3.0和Vue2.0的区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"新增组合式API，更好地聚合功能代码。\\n全局Vue API更改为使用应用程序实例，createApp创建一个应用实例。例如Vue.use()改为createApp().use()。\\n同一元素上的v-if和v-for的优先级发生改变，v-if无法访问v-for的变量。\\n等等\\n更多变化请见知识点中官网的说明。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "142",
      "title": "vue父子组件挂载顺序？",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "父子组件挂载顺序",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cc5ehy#dZvl9"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"vue父子组件挂载顺序是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"加载渲染过程\\n父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created ->子 beforeMount -> 子 mounted -> 父 mounted\\n更新过程\\n父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated\\n销毁过程\\n父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed\\n\"}]}",
      "quizes": ["5", "9", "14"]
    },
    {
      "id": "143",
      "title": "vue computed和watch的区别",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "computed和watch的区别",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cc5ehy#Cg81t"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["网易", "京东", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"讲一下vue组件的computed和watch的区别。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"应用场景不同\\ncomputed用在根据data属性或者其他computed计算得到一个新值的情况，computed的值一般被用在渲染中。\\nwatch用在监听数据变化，然后做一些有副作用的操作的场景。\\n\\n执行过程不同\\n在依赖的data属性变化后，computed并不会重新计算新的值，而是等到访问的时候再判断，如果依赖的data有改动则重新计算并返回结果，如果依赖的data没有改动，就不计算，直接返回当前结果。\\n依赖的数据变化后就会执行watch的回调。\\n\"}]}",
      "quizes": ["5", "9", "14"]
    },
    {
      "id": "144",
      "title": "vue组件data为什么是函数",
      "type": 1,
      "level": 14,
      "knowledge": [],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["网易", "美团", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"vue组件data为什么是函数?\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"如果data不是一个函数，或者函数中不是返回一个对象字面量，那么实例化多个组件的话，不同组件间会共享同一个data，data的改变会影响到每个实例，这时不符合预期的。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "145",
      "title": "vue组件data用箭头函数行不行？",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "data",
          "url": "https://cn.vuejs.org/v2/api/#data"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["快手"],
      "question": "{\"ops\":[{\"insert\":\"vue组件data用箭头函数行不行？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"可以使用箭头函数，但是需要注意this指向。\\n如果使用箭头函数，data函数中的this不会指向vue实例，如果需要访问vue实例，可以通过data函数的参数来实现。\\ndata: vm => ({ a: vm.myProp })\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "146",
      "title": "Vuex工作机制",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "vuex",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/xos4ss"
        },
        {
          "name": "官网介绍",
          "url": "https://vuex.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%E2%80%9D%EF%BC%9F"
        }
      ],
      "category": "前端编程基础/框架/vue/vuex",
      "tags": ["阿里", "京东"],
      "question": "{\"ops\":[{\"insert\":\"vuex的数据流向？vuex整个触发过程（actions，state，view）？\\nvuex的工作原理？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Vuex的数据流是组件中触发action，action提交mutations，mutations修改states。 组件根据 states或getters来渲染页面。\\nVuex是个状态管理器。\\n它Vuex通过createStore创建了一个数据中心，然后通过发布-订阅模式来让订阅者监听到数据改变。\\nVuex的store注入 vue的实例组件的方式，是通过vue的 mixin机制，借助vue组件的生命周期钩子beforeCreate 完成的。这样Vue组件就能通过this.$store获取到store了。\\nVuex使用vue中的reactive方法将state设置为响应式，这样组件就可以通过computed来监听状态的改变了。\\n\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "147",
      "title": "vue-router原理以及两种模式区别",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "两种历史记录模式",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/pkywsg#SHnGb"
        }
      ],
      "category": "前端编程基础/框架/vue/vue-router",
      "tags": ["网易", "百度", "字节", "美团", "快手", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"路由有哪两种模式？默认是哪种模式？\\n两种模式区别是什么？\\n讲一下vue-router原理？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"前端路由有两种模式，HTML5和hash，这两种模式本质是不同的底层浏览器技术，但是上层Vue Router做了统一化的封装，因此在我们开发组件和配置路由时候使用这两种模式的区别并不大。默认是hash模式。\\n\\n这两种模式有几个主要区别\\n1. HTML5模式的路由没有\\\"#\\\"字符，而是在域名后直接写路径，更加优雅\\n2. 由于#后面的字符不会发给服务器，因此hash路由SEO比较差\\n3. HTML5需要服务器在访问不同的路径时候都能fallback到index.html，因此相对麻烦\\n\\n前端路由的原理关键有2点\\n1. 可以修改url，但不会引起刷新，从而在不刷新的页面的情况下跳转路由。\\n2. 监听url改变，根据url渲染对应组件。\\n\\nhash模式和history模式的原理都是基于这两点。hash是通过浏览器提供的location API修改url，通过onhashchange方法监听hash改变；history通过浏览器提供的history.pushState或者history.replacestate修改url，通过popState事件监听url改变。\\n\"}]}",
      "quizes": ["5", "9", "14"]
    },
    {
      "id": "148",
      "title": "vue-router用法",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "vue-router",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/pkywsg"
        }
      ],
      "category": "前端编程基础/框架/vue/vue-router",
      "tags": ["快手", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"说说vue-router的用法，如何动态传参？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"见知识点\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "149",
      "title": "v-if和v-show的区别",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "v-if VS v-show",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cc5ehy#ntT8O"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["百度", "腾讯", "网易", "字节", "美团", "快手", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"vue中的v-if指令和v-show指令区别是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"行为不同：v-if指令在满足条件时候才会渲染DOM，v-show一开始就渲染DOM，满足条件时候才设置CSS的display属性让元素显示出来。\\n应用场景不同：一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "150",
      "title": "v-for和v-if放在一起用好吗",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "避免 v-if 和 v-for 用在一起",
          "url": "https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["网易"],
      "question": "{\"ops\":[{\"insert\":\"v-for和v-if放在一起用好吗\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"v-if和v-for不要同时使用，因为会在每次渲染时候都要遍历列表并判断是否需要渲染，这个遍历操作其实是有一部分冗余或者完全不必要的。\\n应该用以下方式替换v-if和v-for同时使用的方案：\\n1. 如果是为了过滤一个列表中的项目（v-for循环，v-if过滤条件），可以将列表作为计算属性，在computed中过滤出需要渲染的列表，再进行渲染。这样避免了每次渲染都计算（只在computed依赖的属性变化时候才计算），同时渲染列表是过滤了的，那么循环的次数也可能减少。\\n2. 如果是为了控制整个列表的展示和隐藏（v-for循环，v-if判断整个列表是否需要展示），可以将判断条件放到父元素（ul、ol）上。这样展示和隐藏的判断只需要执行一次（在列表最开始）。\\n\\nVue3修改了v-if和v-for的优先级，v-if没有权限访问v-for的变量，这个需要注意。\\n\"}]}",
      "quizes": ["5", "9", "14"]
    },
    {
      "id": "151",
      "title": "vue组件样式污染",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "style标签中的scoped属性",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cc5ehy#qtJw5"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["腾讯"],
      "question": "{\"ops\":[{\"insert\":\"如何避免vue组件的样式污染？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"在style标签中添加“scoped”属性，可以避免当前组件的CSS污染全局。\\n添加了这个属性后，vue-loader会给组件的每个元素添加一个data属性，并且将CSS代码编译，添加这个data属性的选择器。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "152",
      "title": "Vue如何给一个对象添加新的属性",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "深入响应式原理.检测变化的注意事项.对于对象",
          "url": "https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["腾讯", "美团", "快手"],
      "question": "{\"ops\":[{\"insert\":\"Vue如何给一个对象添加新的属性？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"使用Vue.set(object, propertyName, value)或者vm.$set((object, propertyName, value)。这两个方法相同。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "153",
      "title": "vue响应式原理",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "Vue响应式原理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gn1maz"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["阿里", "美团", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"讲一下vue响应式原理？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Vue通过数据代理改变组件的数据访问和设置的行为，在访问时候收集依赖，在设置时候通知订阅者。\\n更详细的说明请参考知识点。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "154",
      "title": "vue的compile过程",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "模板编译原理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/msfggi#wyMVN"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["阿里"],
      "question": "{\"ops\":[{\"insert\":\"说一下vue的compile的过程。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Vue在实例化组件时候会生成虚拟DOM，Vue先判断是否有render函数，如果有的话调用render生成虚拟DOM；如果没有render函数，则获取template选项，template选项可以是选择器、模版字符串、dom元素，Vue根据template选项进行模板编译；如果没有template，则获取el以及其子内容作为模版。\\n\\n模板编译有三个步骤\\n1. 将模板解析为AST。（Abstract Syntax Tree，抽象语法树）。\\n2. 遍历AST标记静态节点。\\n3. 使用AST生成渲染函数。\\n\"}]}",
      "quizes": []
    },
    {
      "id": "155",
      "title": "vue的computed和watch的实现原理",
      "type": 1,
      "level": 8,
      "knowledge": [
        {
          "name": "computed",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gn1maz#YyZET"
        },
        {
          "name": "watch",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gn1maz#nbONC"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["阿里", "美团"],
      "question": "{\"ops\":[{\"insert\":\"讲一下vue的computed和watch的实现原理？computed是怎么收集依赖的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"computed：\\ncomputed是data属性的一个订阅者，它在初始化时候被data属性收集依赖，当computed依赖的data属性改变后，标记该computed为dirty，即数据更改过，当渲染使用到computed时候，再计算出computed的值从而得到最新的正确的值。\\nwatch：\\n在组件初始化时候，遍历所有的watch，对每个watch创建订阅者，绑定依赖的data属性，当data属性改变后发布给订阅者，然后会执行相应地回调。\\n更详细的说明请参考知识点。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "156",
      "title": "vue的模板渲染",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "模板渲染原理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/msfggi#SG1My"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"介绍一下vue中模板渲染原理？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Vue会根据将模板编译成render函数，调用render函数生成虚拟dom，然后将虚拟dom映射成真实dom。\\n当数据变化时候，Vue会触发更新视图，调用render函数返回新的虚拟dom，对比新旧虚拟dom，修改真实dom，从而更新界面\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "157",
      "title": "vue数据双向绑定原理",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "双向绑定",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gn1maz#qFjEn"
        },
        {
          "name": "把data设置为响应式",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gn1maz#np3Ia"
        },
        {
          "name": "数据代理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gn1maz#U6l5v"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": [
        "网易",
        "美团",
        "滴滴",
        "快手",
        "拼多多",
        "百度",
        "阿里",
        "腾讯"
      ],
      "question": "{\"ops\":[{\"insert\":\"讲一下vue数据双向绑定原理，依赖收集的过程，vue2数据绑定缺点是什么？vue3是怎么解决的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"双向绑定原理 请参考知识点《双向绑定》\\n依赖收集过程 请参考知识点《把data设置为响应式》\\nVue2数据绑定缺点和Vue3解决方法 请参考知识点《数据代理》\\n\"}]}",
      "quizes": ["5", "9", "14"]
    },
    {
      "id": "158",
      "title": "vue怎么检测到数组的变化",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "数据代理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gn1maz#U6l5v"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["腾讯", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"给数组添加元素时候，vue是怎么检测到数据的变化的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Vue2通过重写数组方法实现，Vue3通过Proxy数据代理实现。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "159",
      "title": "Vue的diff算法",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "diff算法",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/msfggi#vInDL"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["腾讯", "百度", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"vue的虚拟dom是如何做diff的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"请参考知识点\\n\"}]}",
      "quizes": ["5", "9", "14"]
    },
    {
      "id": "160",
      "title": "vue nextTick",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "nextTick",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/emrqth#WRLen"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["腾讯", "快手"],
      "question": "{\"ops\":[{\"insert\":\"vue的nextTick方法的原理及使用场景？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Vue使用MutationObserver/Promise/setTimeout实现nextTick。Vue判断浏览器兼容性，按照MutationObserver -> Promise -> setTimeout的优先级实现nextTick。\\n场景是在修改数据之后，想要访问修改后的DOM时候，可以用Vue.nextTick，在下个循环中访问，这样才能访问到修改后的结果。\\n\"}]}",
      "quizes": ["5", "9", "14"]
    },
    {
      "id": "161",
      "title": "vue的keep-alive组件",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "keep-alive组件",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ef0rpg#oSxzm"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["字节", "京东", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"讲一下vue的keep-alive组件，什么时候会用到？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"keep-alive是一个内置组件，它所包裹的组件会在不同的渲染中缓存状态。用在需要让自定义组件在不同的渲染中保持状态不变的场景。例如一些表单组件，如果已经填写好一些内容，然后切到其他组件，再切换回表单时候，应该保持已经填写好的内容，这时候可以选择使用keep-alive。\\n\"}]}",
      "quizes": ["5", "9", "14"]
    },
    {
      "id": "162",
      "title": "Vue的数据为什么频繁变化但只会更新一次",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "异步渲染",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/emrqth#lxmUU"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["阿里"],
      "question": "{\"ops\":[{\"insert\":\"Vue的数据为什么频繁变化但只会更新一次？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Vue可以响应数据变化，数据变化后会自动更新视图，如果每次修改都触发视图更新，会导致多次重复和不必要的渲染操作，例如一个组件使用了两个data的属性，更新两个属性如果触发两次渲染的话，会影响性能。因此Vue采取异步更新。\\n每次更新响应的属性之后，会将渲染的watcher放到一个队列中，在下个事件循环中再执行。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "163",
      "title": "process.nextTick和Vue.nextTick",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "nextTick",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/emrqth#WRLen"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"process.nextTick和Vue.nextTick的区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Vue.nextTick是将任务加入到宏任务队列或者微任务队列。\\nprocess.nextTick并未将任务加入到宏任务队列或者微任务队列，它是将任务加到下次事件循环之前。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "164",
      "title": "vue组件watch中deep和immediate的作用",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "watch",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cc5ehy#ei9Fz"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["美团"],
      "question": "{\"ops\":[{\"insert\":\"vue组件watch中deep和immediate的作用\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"watch有两个选项：deep和immediate，deep决定是否深度监听，即是否监听多层对象数据，immediate决定是否立即执行，如果为true，会在绑定时候（初始时候）立即执行，如果为false，只在监听的值变更时候执行。默认为false。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "165",
      "title": "slot",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "slot",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ef0rpg#oIKe8"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["滴滴", "京东", "快手"],
      "question": "{\"ops\":[{\"insert\":\"讲讲slot？有什么作用？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"插槽是Vue 实现的一套内容分发的 API，它支持在渲染一个自定义组件时候，向它“插入”一些内容。这个自定义组件会将起始标签和结束标签之间的内容渲染到自己模板中“slot”组件所在的位置上。\\nVue的插槽和React的render props的作用相同，React也会将自定义组件开始和闭合标签之间的内容作为children属性挂载到props上，从而在自定义组件中渲染处理。\\n插槽（和render props）提供了更灵活的组件组合和复用方式，在布局等应用场景让代码更直观和易于维护。\\n\\n\"}]}",
      "quizes": []
    },
    {
      "id": "166",
      "title": "vue异步渲染、nextTick",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "异步渲染和nextTick",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/emrqth"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"Vue组件为什么采用异步渲染？异步渲染原理是什么？nextTick的原理？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"请参考知识点。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "167",
      "title": "vue如何实现自定义指令",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "自定义指令",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ef0rpg#ydHKv"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"vue如何实现自定义指令？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"使用Vue.diractive全局注册或者在组件的directive属性中，通过钩子来实现自定义指令。\\n详细说明请参考知识点和官网。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "168",
      "title": "Vue.use方法的使用",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "Vue插件",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ef0rpg#Gbrn8"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"Vue.use方法的使用？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"通过调用Vue.use()方法来安装插件，插件是一个构造函数，它必须实现一个install方法，Vue会调用install方法，并传入Vue变量，让插件可以使用Vue来向Vue添加全局功能。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "169",
      "title": "vue和react的区别",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "对比其他框架",
          "url": "https://cn.vuejs.org/v2/guide/comparison.html"
        },
        {
          "name": "Vue和React的对比",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/yobabe#TxU07"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["阿里", "美团", "京东", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"vue和react的区别是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"请参考知识点，Vue官方的比较。\\n个人观点：\\n首先React和Vue在框架设计上有很多相同点\\n1、使用 Virtual DOM\\n2、提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。\\n3、将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。\\n\\n性能、包体积大小也都不是决定性因素。\\n\\n它们的差别更多体现在编码风格和使用细节上：\\n1、React的API简洁，Vue的API更多，因此使用Vue编写代码可能更少。\\n2、Vue更容易上手（因为帮开发者做了很多事情，computed、双向绑定等），React要实现相同功能需要用户手操作，例如需要通过受控组件来实现表单的数据同步，不如Vue的v-model语法糖更便捷。而且Vue的模板语法更贴近原生，因而更容易接受和理解。\\n3、React虽然API简单，但也因此在某些场景需要一些实践来优化，如shouldComponentUpdate，Vue使用数据劫持，能够做到改变了才触发渲染，更精准。\\n4、模板语法 VS JSX语法，其实Vue也可以支持JSX，JSX表达能力更强，模板语法更直观。\\n5、React有一些主张，例如纯函数等，对编写项目有一定的限制，有的观点认为React规范能尽可能保证项目少出bug，所以更适合大型项目。\\n6、react社区较大，Vue及周边都主要是官方在维护，更稳定一些。\\n7、超大规模的首屏渲染上React有一些优势，因为Vue需要做一些初始化工作。\\n8、React组件是继承React.Component，Vue是对象，因此React可以实现基于继承的组件复用（虽然并不推荐），而Vue不行。\\n在响应式原理上也存在差别：\\nReact和Vue在响应式的原理上有所不同，Vue是通过数据劫持，实现当数据变化时候响应式更新，React是在setState时候diff组件树。\\n\"}]}",
      "quizes": ["5"]
    },
    {
      "id": "170",
      "title": "vue父子组件通信，兄弟组件通信",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "vue组件通信",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cc5ehy#mlSBz"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["百度", "美团", "字节", "滴滴", "京东", "网易", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"vue父子组件如何通信？兄弟组件如何通信？如何使用eventBus通信？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"父子组件通信有3种方式：\\n1、props\\n2、事件\\n3、ref\\n兄弟组件通信有2种常用方式：\\n1、eventBus\\n2、vuex\\n\\neventBus就是一个vue实例，使用它提供的$on和$emit就能够很容易地实现发布订阅模式，从而实现兄弟组件间的通信。\\n\"}]}",
      "quizes": ["5", "9", "14"]
    },
    {
      "id": "171",
      "title": "vue的eventbus的实现",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "eventBus",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cc5ehy#TGyJH"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["字节", "滴滴", "京东", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"eventBus原理是什么？为什么可以实现组件间的状态共享？\\n它是什么模式？发布者订阅者分别是做什么的？\\nvue的eventbus如何实现？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"eventBus是一个典型的发布-订阅模式，当状态改变时候，改变方通过eventBus发布状态改变事件，关心这个状态的组件可以通过订阅该事件来获知最新的状态，这样就实现组件通信，即组件间的状态共享。\\nVue项目中可以通过简单地实例化一个Vue对象来实现一个eventBus：\\n```\\nconst eventBus = new Vue();\\n```\\n然后使用实例提供的\"},{\"attributes\":{\"color\":\"#b5cea8\"},\"insert\":\"$\"},{\"insert\":\"on()方法订阅，使用\"},{\"attributes\":{\"color\":\"#b5cea8\"},\"insert\":\"$\"},{\"insert\":\"emit()方法实现发布。\\n另外可以通过$off()解绑事件。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "172",
      "title": " React、Vue和JQuery的选型",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "Vue和React的对比",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/yobabe#TxU07"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["阿里", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"React、Vue和JQuery在不同场景下怎么选型？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"首先，Vue和React在很多地方都是相似的，对于大部分场景，并没有React能做到而Vue不能做到，或者Vue能做到，而React不能做到的事情。所以决定Vue和React之间的选型的因素更多是团队成员的熟练程度、老项目的情况、整个公司的环境、团队的沉淀、甚至领导的个人偏好。\\n至于JQuery，一般已经不使用了。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "173",
      "title": "vue和jquery的区别",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "Vue和JQuery对比",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/yobabe#Ff8gJ"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["字节", "美团", "京东", "网易"],
      "question": "{\"ops\":[{\"insert\":\"vue和jquery的区别是什么？为什么jquery被淘汰了？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"1、目标不同，JQuery关注简化js的DOM操作和浏览器兼容性处理，帮助开发者更简单地操作DOM，Vue关注用户如何组织代码，让开发者不需要操作DOM，可以更好地组织代码，提升项目的可读性和可维护性。\\n2、对于大型项目JQuery未规定代码组织形式，未提供组件化的标准，因此多人开发时候不同风格代码混杂，很容易造成代码混乱，相对而言，Vue就更适合大型的项目。\\n3、如果需要在项目中引入组件库的话，Vue项目的组件库更标准化，JQuery的组件库则形式多样，很难和自己的项目风格保持一致。\\n4、跨平台，Vue使用声明式渲染，通过虚拟DOM映射到真实DOM，可以实现跨平台，而JQuery没有这种能力。\\n5、由于Vue支持声明式渲染，因此可以做到服务端渲染和客户端代码同构，降低项目复杂度和学习成本（不需要再学习一门模板语言）。JQuery项目实现服务端渲染还要依赖一个后端的模板语言。\\n6、发展趋势不同，随着浏览器标准化和前端项目的复杂度逐步提升，JQuery的应用场景在一点点减少，Vue作为新一代前端框架正在蒸蒸日上。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "174",
      "title": "computed和watch的区别",
      "type": 1,
      "level": 14,
      "knowledge": [],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["快手", "阿里", "京东", "腾讯", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"computed和watch的区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"1、场景不同，computed是计算属性，用在渲染或者其他获取计算属性值的地方，watch是定义的订阅者，订阅数据改变，执行回调。\\n2、使用方式不同，computed是直接取值，watch是监听改变，执行回调。\\n3、computed方法不应该有副作用，watch方法则无此要求。\\n4、computed是惰性求值，只有依赖的数据发生改变，并且其他地方使用到了这个值，才会调用方法进行计算；watch则是每次依赖的数据改变，都会触发执行。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "175",
      "title": "computed和method的区别",
      "type": 1,
      "level": 14,
      "knowledge": [],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["快手"],
      "question": "{\"ops\":[{\"insert\":\"computed和method的区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"虽然它们都是定义了方法，但是computed和method有很大区别\\n1、场景不同，computed是计算属性，用在渲染或者其他获取计算属性值的地方，method是定义的方法，用在声明周期、交互回调等地方。\\n2、使用方式不同，computed是直接取值，method是调用方法。\\n3、computed方法不应该有副作用，method则无此要求。\\n4、computed是惰性求值，只有依赖的数据发生改变，并且其他地方使用到了这个值，才会调用方法进行计算；method是每次调用会立刻执行。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "176",
      "title": "vue组件的生命周期",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "组件生命周期钩子",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cc5ehy#ujXeW"
        }
      ],
      "category": "前端编程基础/框架/vue/基本用法",
      "tags": ["阿里", "腾讯", "京东", "网易", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"一、讲一下vue的生命周期钩子？什么是生命周期钩子？\\n二、有哪些常用的生命周期钩子？\\n三、在这些常用的生命周期钩子中一般会做哪些操作？\\n四、3.0新加了哪些？\\n五、父子组件生命周期先后顺序？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"一、生命周期钩子说明：\\n在组件被加载后，在应用运行过程中，组件可能会经历挂载、数据更新、销毁等各个阶段，称为组件的生命周期。每个阶段会执行相应的生命周期钩子，用户可以在生命周期钩子中处理业务逻辑。\\n二、Vue的生命周期钩子\\n1、创建：beforeCreate、created\\n2、挂载：beforeMount、mounted\\n3、更新：beforeUpdate、updated\\n4、销毁：beforeDestroy、destroyed（Vue3中被更改为 beforeUnmount、unmounted）\\n三、在这些常用的生命周期钩子中一般会做哪些操作？\\n通常我们会在初始化（created/mounted）中绑定事件、启动定时器，相应地，在beforeDestroyed中解绑事件、停止定时器。\\n在updated中执行一些依赖新状态，或者依赖新的DOM的操作，例如一个聊天面板组件中，收到消息后更新数据，在update中需要判断，如果当前面板的列表是向上滚动的状态，即用户正在会看之前的消息，就给一个提示“有新消息”，如果列表处在底部，就自动向上滚动，展示出最新消息。\\n四、Vue3.0增加了beforeUnmount、mounted，用来代替beforeDestroy、destroyed。\\n五、父子组件生命周期顺序：\\n加载渲染过程\\n父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted。\\n更新过程\\n    父beforeUpdate->子beforeUpdate->子updated->父updated。\\n销毁过程\\n    父beforeDestroy->子beforeDestroy->子destroyed->父destroyed。\\n\"}]}",
      "quizes": []
    },
    {
      "id": "177",
      "title": "为什么Vue是渐进式框架",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "Vue渐进式",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/yobabe#nH4ow"
        }
      ],
      "category": "前端编程基础/框架/vue/原理",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"为什么Vue是渐进式框架？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"渐进式的概念：分层设计，每层可选，不同层可以灵活接入其他方案。\\n那么Vue的设计分这样几层\\n1、declarative rendering（声明式渲染）\\n2、component system（组件系统）\\n3、client-side routing（前端路由）\\n4、state management（状态管理）\\n5、build system（构建系统）\\n使用Vue时候可以只用它核心的视图层，也可以使用其路由、状态管理、脚手架等，如果用户有个人偏好也可以接入其他解决方案，因此Vue是渐进式的框架。\\n\"}]}",
      "quizes": ["5", "9"]
    },
    {
      "id": "178",
      "title": "mvvm与mvc",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "MVVM",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/vg5tas"
        }
      ],
      "category": "前端编程基础/框架/思想/mvvm",
      "tags": ["阿里", "字节", "美团"],
      "question": "{\"ops\":[{\"insert\":\"什么是MVVM？与MVC有什么区别？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"MVVM是一种软件架构设计模式，它抽离了视图、数据和逻辑，并限定了Model和View只能通过VM进行通信，VM订阅Model并在数据更新时候自动同步到视图。\\n\\nMVC将应用抽象为数据层（Model）、视图层（View）、逻辑层（controller），降低了项目耦合。但MVC并未限制数据流，Model和View之间可以通信。\\nMVP则限制了Model和View的交互都要通过Presenter，这样对Model和View解耦，提升项目维护性和模块复用性。\\n而MVVM是对MVP的P的改造，用VM替换P，将很多手动的数据=>视图的同步操作自动化，降低了代码复杂度，提升可维护性。\\n\"}]}",
      "quizes": ["", "14"]
    },
    {
      "id": "179",
      "title": "React性能优化",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "React性能优化",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/rf4oz1"
        }
      ],
      "category": "前端编程基础/框架/react/基础用法",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"使用React时候做过什么优化？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"（阅读知识点，查看详细讲解）\\n1、避免不必要的渲染\\n    属性值没有改变时候不需要重新渲染，通过React.PureComponent + shouldComponentUpdate，或者React.memo来实现。\\n2、Fragment\\n    避免不必要的标签，如果想返回一个标签列表，可以使用React.Fragment包裹。\\n3、事件回调不使用匿名函数或者bind\\n    如果事件函数用匿名函数或者bind的函数，每次render时候都要解绑旧的函数，绑定新的函数，这时不必要的，类组件中，事件回调应该作为组件的一个属性；函数组件中可以用useCallback实现每次返回同一个函数。\\n4、不要用内联样式，防止解析操作耗时。\\n5、不要在render中setState，可能造成死循环。实际上render函数应该是个纯函数，没有任何副作用。\\n6、优化条件渲染\\n    让条件分支中只包含需要改动的元素，不包含不需要改动的元素，防止diff子节点和更新节点时候增加不必要的操作，消耗性能。\\n7、缓存计算属性\\n    使用memorize-one库缓存计算量大的值，在函数组件中使用useMemo缓存计算的值。\\n8、长列表优化\\n    对于长列表，可以只渲染可视区及附近的元素，这样不用挂载大量DOM，节省很多性能。可以用react-vitualize库。\\n9、concurrent mode\\n    启用concurrent mode之后，React会采取可中断渲染，让大规模的diff计算不会影响到界面的渲染，保证渲染和交互的流畅性。\\n    使用Suspense组件可以在加载局部组件时候有更好的切换加载体验。\\n10、列表中使用key\\n    不使用key或者用index作为key，都可能使列表在变化时候，让React无法辨别前后item对应关系，只能遍历对比，更新属性，这样可能会有多余的操作，造成性能损耗。\\n\"}]}",
      "quizes": ["5", "10", "14"]
    },
    {
      "id": "180",
      "title": "React列表的key",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "列表的key",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ghwsyx#MFVAL"
        }
      ],
      "category": "前端编程基础/框架/react/原理",
      "tags": ["百度", "美团", "滴滴"],
      "question": "{\"ops\":[{\"insert\":\"react的列表中为什么需要key属性？\\nkey属性如果赋值为数组的index，会有什么问题吗？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"不加key或者key使用index赋值，都会列表变动后导致React无法辨别item前后的对应关系。\\n这可能带来两种问题：\\n① 性能损耗，因为无法正确识别列表中元素变化，可能做一些多余的更新属性的操作，造成性能损失。\\n② 非受控的表单的值不符合预期，因为无法正确识别列表中元素变化，对于非受控的表单，React无法知道表单的变化，也就没法正确地更新其值。\\n\"}]}",
      "quizes": ["5", "10", "14"]
    },
    {
      "id": "181",
      "title": "redux原理是什么？实现一个redux",
      "type": 3,
      "level": 12,
      "knowledge": [
        {
          "name": "redux的使用",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gd90zo#nlp2F"
        }
      ],
      "category": "前端编程基础/框架/react/redux",
      "tags": ["美团", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"讲一下redux的使用，和redux架构。\\n实现一个redux，实现createStore，store的发布订阅、取消订阅功能。用TS实现。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"Redux有3大核心，actions、store和reducer。Redux维护一个state，接受用户定义的reducer，用于根据action计算新的state，当用户触发action后，Redux调用reducer计算新的state，更新state，然后将新的state发布给订阅者。\\n下面简单地实现createStore方法，更详细的实现，请阅读知识点文章和redux源码。\\ninterface IStore {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  subscribe: (cb: Function) => void,\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  getState: () => Object,\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  dispatch: (action: Object) => void\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"const createStore = (reducer: Function): IStore => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  let state = reducer();\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  const listeners = [];\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  const subscribe = cb => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"    listeners.push(cb);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"    return () => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"        const index = listeners.indexOf(cb);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"        listeners.splice(index, 1);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"    };\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  };\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  const getState = () => state;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  const dispatch = action => {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"    state = reducer(action);\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"    listeners.forEach(listener => listener());\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  };\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  return {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"    subscribe, getState, dispatch\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"  };\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"};\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "182",
      "title": "为什么使用Redux",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "什么时候需要Redux",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/gd90zo#o23Tq"
        }
      ],
      "category": "前端编程基础/框架/react/redux",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"为什么要使用 Redux，是不是所有项目都必须要使用 Redux？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"如果页面很简单，或者虽然有多个页面，但是页面之间彼此独立，页面之间、组件之间不需要共享状态，那么引入Redux没有意义。\\n如果页面的组件之间跨层级通信或者页面的不同部分共享状态的情况很多，那么仅仅用状态提升来实现组件间通信就会非常杂乱，这时候就需要Redux来帮助管理应用的状态。\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "183",
      "title": "react-router是怎么实现的",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "React Router原理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/cu1cr4#Rlvi1"
        }
      ],
      "category": "前端编程基础/框架/react/react-router",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"react-router是怎么实现的\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"前端路由的实现有两个关键点：\\n1、改变url，而不触发页面刷新\\n2、监听url改变，重新渲染对应url的界面\\nReact-Router和Vue-Router等路由库的原理大致类似，都支持了\\n前端路由的两种模式：history和hash，这两种模式都是利用了浏览器提供的API，实现了上面的两点：无刷新修改url和监听url改变。\\nhistory前端路由利用了history API\\nhistory.back() // 回退\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"history.forward() // 前进\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"history.go() // 跳转到history栈中的指定点\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"history.pushState() // 在history栈中增加一个记录\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"history.replaceState() // 将当前的记录替换为新的记录\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"﻿\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"window.onpopstate = () => {} // url改变的监听\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"注意，history.pushState()或者history.replaceState()不会触发popstate事件，因此需要封装pushState和replaceState方法，在调用pushState和replaceState时候通知订阅者。这样就能监听到url的改变了。\\nhash前端路由利用了hash API\\nlocation.href = 'XXX#123' // 修改url（#后面的改动不会触发页面重新渲染）\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"window.onhashchange = () => {} // “#”后面的改动会触发onhashchange回调。\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "184",
      "title": "React组件之间如何通信",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "React父子组件通信",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/iui0gp#yOr8k"
        }
      ],
      "category": "前端编程基础/框架/react/基础用法",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"React组件之间如何通信\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"父子组件通信可以通过下面3种方法通信\\n1、父组件给子组件传递props数据\\n2、子组件回调父组件传的方法\\n3、父组件通过ref获得子组件的引用，调用子组件的方法\\n兄弟组件可以通过2种方法通信\\n1、事件总线\\n2、状态管理工具（redux、mobx）\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "185",
      "title": "useState和userRef",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "hook",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tgc3uo#WV7QL"
        }
      ],
      "category": "前端编程基础/框架/react/hook",
      "tags": ["滴滴", "字节"],
      "question": "{\"ops\":[{\"insert\":\"useState和userRef怎么用？useState如何实现的？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"useState可以给函数式组件添加状态\\n1、useState函数接收一个参数作为初始值\\n2、useState返回值为一个数组，数组第一个元素是状态变量，第二个元素是设置该状态的方法\\n3、调用设置状态的方法，会同步触发diff和更新操作\\nuseRef可以用来实现获取一个原生DOM或者子组件实例的引用，本质上，它可以用来保存任何可变值。\\n1、useRef接收一个参数作为初始值。\\n2、useRef返回一个对象，这个对象包含一个current属性，这个current属性会被初始化为初始值，并且可以更改。\\n3、每次调用渲染函数，都返回同一个对象。\\n\\n（useState原理详解请查看知识点）\\nuseState工作的过程如下：\\n1、首次调用函数组件，执行useState，React获取到当前正在遍历的节点，创建_state对象挂载到节点上，根据调用useState的顺序，在数组中加入状态，并根据传入的初始值初始化状态。\\n2、当调用状态的set方法时候，React修改_state上面的状态，并更新相应的组件。\\n3、后面再调用函数组件时候，useState找到对应的节点的_state，并根据useState的调用顺序，找到修改后的状态返回，这样组件就可以拿到正确的状态了。\\n\"}]}",
      "quizes": ["5", "10", "14"]
    },
    {
      "id": "186",
      "title": "常用的hook",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "hook",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tgc3uo#WV7QL"
        }
      ],
      "category": "前端编程基础/框架/react/hook",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"说一下常用的hook的使用方法和应用场景。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"useState\\n    在函数式组件中添加状态需要使用useState这个hook\\nuseEffect\\n    在函数式组件中添加一些有副作用的操作（如网络请求、操作DOM、绑定事件回调），需要用到useEffect这个hook。\\nuseMemo\\n    useMemo的作用类似于Vue中的computed，会缓存计算结果，只有当依赖的数据改变时候，才会执行其中的计算方法。\\nuseCallback\\n    一般用于生成事件处理函数，防止每次生成新的函数，导致不必要的子组件重新render。场景是计算属性和注册回调。\\nuseRef\\n    useRef可以用来实现获取一个原生DOM或者子组件实例的引用，本质上，它可以用来保存任何可变值。\\n\"}]}",
      "quizes": ["5", "10", "14"]
    },
    {
      "id": "187",
      "title": "React的生命周期钩子",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "React生命周期钩子",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/tgc3uo#DoEq0"
        }
      ],
      "category": "前端编程基础/框架/react/基础用法",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"React的生命周期钩子？\\nReact16的生命周期有什么改变？\\n详细介绍一下getDerivedStateFromProps。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"请阅读知识点\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "188",
      "title": "react里有动态加载的api吗？",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "React.lazy原理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/rd78rg#ePOzd"
        }
      ],
      "category": "前端编程基础/框架/react/基础用法",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"React里有动态加载的api吗？\\nReact.lazy的原理是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"React里动态加载组件的API是React.lazy。\\n// 引用MyComponent\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const AsyncComponent = React.lazy(() => import('./MyComponent'));\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"// MyComponent.js\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"// ...\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"export default class MyComponent extends React.Component {\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"  // ...\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"}\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"React.lazy核心逻辑就是throw一个异步加载组件的promise，加载好后return这个组件（所以如果其外部不包裹Suspense，也没有ErrorBoundary的话，页面就会崩溃）。\\nReact.lazy接收一个函数作为参数，这个函数需要返回一个thenable对象。React.lazy会先执行方法，得到异步加载组件的promise，然后throw这个promise。promise被Suspense捕获后进入异步处理队列，等组件加载好后，React.lazy就返回thenable对象resolve的对象的default属性，这个default属性就是异步加载的组件。\\n\\n\"}]}",
      "quizes": ["5", "10"]
    },
    {
      "id": "189",
      "title": "webpack原理",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "webpack原理",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/vypyf0"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["阿里", "美团", "京东", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"webpack工作的原理是什么？工作流程是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"webpack读取配置，根据入口开始遍历文件，解析依赖，使用loader处理各模块，然后将文件打包成bundle后输出到output指定的目录中。\\nwebpack的工作流程是\\n1、Webpack CLI 启动打包流程，解析配置项参数。\\n2、载入 Webpack 核心模块，创建 Compiler 对象。\\n3、注册plugins。\\n4、使用 Compiler 对象开始编译整个项目。\\n5、从入口文件开始，解析模块为AST，分析模块依赖，形成依赖关系树。\\n6、递归依赖树，将每个模块交给对应的 Loader 处理。\\n7、合并 Loader 处理完的结果，将打包结果输出到 dist 目录。\\n\\n\"}]}",
      "quizes": ["5", "11", "14"]
    },
    {
      "id": "190",
      "title": "webpack的tree-shaking",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "使用Tree Shaking擦除无用的js和css",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/oqxr9u#JCX4Y"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"怎么理解webpack的tree-shaking和css-treeshaing？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"摇树js\\nTree-shaking的本质是消除没有用到的代码。主要的效果是，引用了但没有使用的模块，不会被打包到最终的bundle中。\\nTree-shaking要求模块是ESM,ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。\\n所谓静态分析就是不运行代码，从语法上对代码进行分析，ES6之前的模块化，比如我们可以动态require一个模块，只有执行后才知道是否要引用某个模块，引用的是什么模块，这个就不能通过静态分析去做优化。\\nwebpack默认支持Tree-shaking，如果mode为\\\"production\\\"webpack在构建会做Tree-shaking的操作。\\n\\n摇树css\\n摇树css的基本思路是，给定content和css，分析content中用到的选择器，然后分析css文件中没有用到的选择器，将其移除。\\n摇树css工具有：\\n1、PurifyCSS\\n使用purgecss-webpack-plugin \\n2、uncss \\n\"}]}",
      "quizes": ["5", "11", "14"]
    },
    {
      "id": "191",
      "title": "require引入的模块webpack能做Tree-Shaking吗？",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "使用Tree Shaking擦除无用的js和css",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/oqxr9u#JCX4Y"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"require引入的模块webpack能做Tree-Shaking吗？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"不能，因为require是运行时调用，所以require理论上可以运用在代码的任何地方，没有办法在编译时候就确定模块是否被用到，所以无法彻底地将不用的模块摇掉。\\n\"}]}",
      "quizes": ["5", "11"]
    },
    {
      "id": "192",
      "title": "webpack如何动态加载",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "webpack动态加载",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/to1m2y#uvXYG"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"webpack如何动态加载\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"有两种方法：\\nrequire.ensure（目前已经不推荐）\\n动态import\\n（具体用法请阅读知识点）\\n\"}]}",
      "quizes": ["5", "11"]
    },
    {
      "id": "193",
      "title": "webpack能动态加载require引入的模块吗？",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "带表达式的 require 语句",
          "url": "https://webpack.docschina.org/guides/dependency-management/#require-with-expression"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"webpack能动态加载require引入的模块吗？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"webpack能够支持动态地require，但会导致所有可能用到的模块都包含在bundle中。\\n\"}]}",
      "quizes": ["5", "11"]
    },
    {
      "id": "194",
      "title": "webpack优化",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "webpack性能优化",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/oqxr9u"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["百度", "快手", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"webpack优化方法有哪些？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"提升构建速度：\\n使用高版本的webpack和nodejs\\n多进程多实例构建\\n多进程多实例并行压缩\\n进一步分包：预编译资源模块\\n充分利用缓存提升二次构建速度\\n缩小构建目标\\n使用oneOf\\n\\n提升加载和运行时性能：\\n使用Tree Shaking擦除无用的js和css\\nscope-hoisting\\n使用webpack进行图片压缩\\n优化polyfill方案\\n\\n（优化方法的详细介绍，请阅读知识点）\\n\"}]}",
      "quizes": ["5", "11", "14"]
    },
    {
      "id": "195",
      "title": "webpack模块热重载",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "模块热替换",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/sq7mtz#Yg7lQ"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["阿里"],
      "question": "{\"ops\":[{\"insert\":\"webpack模块热重载的原理？如何在项目中使用模块热重载？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"原理：\\n当我们使用wds打包并启动服务，会在打包的代码中自动加入wds运行时代码，运行时代码用于和wds服务建立一个websocket连接，这个连接用于后续的模块热替换的通信。\\n当我们保存代码后，wds监听本地文件系统更新，会将改动作为补丁通过websocket发送给浏览器端，浏览器端拿到补丁之后不做reload操作，而是对界面进行相应地更新。\\n模块热替换首先需要WDS支持，将运行时代码打包进去，并且启动WDS，监听文件系统并传输补丁等一系列操作。\\n还需要我们的代码在收到补丁时候做相应地处理。\\n使用：\\nWDS默认启动模块热替换功能，对于常见框架，已经有实现了模块热替换功能的工具，我们只需要使用工具就可以实现HMR的能力，对于样式，style-loader本身实现了HMR，因此开发环境使用style-loader即可。\\nReact实现模块热替换有两个方案：\\nreact-refresh-webpack-plugin\\nreact-hot-loader\\n其中react-hot-loader代码侵入性较强，推荐用react-refresh-webpack-plugin。\\n\"}]}",
      "quizes": ["5", "11"]
    },
    {
      "id": "196",
      "title": "happypack",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "happypack",
          "url": "https://www.npmjs.com/package/happypack"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["滴滴"],
      "question": "{\"ops\":[{\"insert\":\"了解happypack吗？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"happypack是一个webpack插件，支持多进程打包，提升打包速度。\\n使用happypack有3步，npmjs中有详细说明。\\n第一步，设置使用happypack-loader解析指定格式的文件\\n第二步，加载happypack插件\\n第三步，设置happypack插件加载指定loader处理文件\\n当webpack加载相应格式的文件时候，会调用happypack-loader，happypack-loader会开启多个进程，并调用第三步配置的loader对文件进行并行处理。\\nhappypack作者已经不怎么维护该plugin，只修改bug。\\n推荐使用webpack的多进程方案thread-loader。\\n\"}]}",
      "quizes": ["5", "11"]
    },
    {
      "id": "197",
      "title": "webpack的plugin和loader",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "编写loader和plugin",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/pgebhl"
        },
        {
          "name": "w-loader",
          "url": "https://github.com/xiaoxiangdaiyu/w-loader"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["百度", "阿里", "快手", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"webpack的plugin和loader有什么区别？写过loader和plugin吗？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"loader用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量等。\\nloader的编写和plugin的编写请参考知识点链接。\\n\"}]}",
      "quizes": ["5", "11", "14"]
    },
    {
      "id": "198",
      "title": "loader的加载顺序",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "loader",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/sq7mtz#CEQ6e"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"在loader数组中，是从左往右还是从右往左编译？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"从右往左。\\n\"}]}",
      "quizes": ["5", "11"]
    },
    {
      "id": "199",
      "title": "常见的webpack plugin和loader",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "loader",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/sq7mtz#CEQ6e"
        },
        {
          "name": "plugin",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/sq7mtz#KmcqO"
        }
      ],
      "category": "工程化/打包构建/webpack",
      "tags": ["美团", "网易", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"说说常见的plugin和loader，它们的功能和使用方法？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"loader\\n1、babel-loader // 处理js\\n2、file-loader、url-loader // 处理图片、字体图标\\n3、less-loader、sass-loader、stylus-loader // 处理各种css预处理器\\n4、css-loader // 解析css模块\\n5、style-loader // 将样式插入到dom中\\n\\nplugin\\n1、html-webpack-plugin // 生成html文件并自动将js bundle引入到html\\n2、clean-webpack-plugin // 每次打包时候清空上次打包结果\\n3、copy-webpack-plugin // 执行拷贝操作\\n4、mini-css-extract-plugin // 提取css文件\\n\"}]}",
      "quizes": ["5", "11", "14"]
    },
    {
      "id": "200",
      "title": "FP、FCP、FMP",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "性能指标",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9#7e687515"
        }
      ],
      "category": "性能优化",
      "tags": ["阿里"],
      "question": "{\"ops\":[{\"insert\":\"FCP/FMP/FP分别是怎样定义，如何统计？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"FP（First Paint），表示渲染出第一个像素点。FP一般在HTML解析完成或者解析一部分时候触发。\\nFCP（First Contentful Paint），表示渲染出第一个内容，这里的“内容”可以是文本、图片、canvas。\\nFMP（First Meaningful Paint），首次渲染有意义的内容的时间，“有意义”没有一个标准的定义，FMP的计算方法也很复杂。\\nFP、FCP都可以通过performance API计算\\n// FP\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const fp = performance.getEntries('paint').filter(entry => entry.name == 'first-paint')[0].startTime;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\\n\"},{\"insert\":\"// FCP\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"const fcp = performance.getEntries('paint').filter(entry => entry.name == 'first-contentful-paint')[0].startTime;\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"FMP计算比较复杂，lighthouse的计算的大体思路是，将页面中最大布局变化后的第一次渲染事件作为FMP事件，并且计算中考虑到了可视区的因素。\\nFMP计算过于复杂，没有现成的performance API，如果希望在监控中上报这个指标，可以自己使用MutationObserver计算。\\n\"}]}",
      "quizes": ["5", "12"]
    },
    {
      "id": "201",
      "title": "回流和重绘",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "渲染过程",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9/edit#816e29dd"
        }
      ],
      "category": "性能优化",
      "tags": ["字节", "美团", "滴滴", "快手", "百度", "阿里", "腾讯"],
      "question": "{\"ops\":[{\"insert\":\"说一下你对回流和重绘的理解，什么时候会重绘？减少回流和重绘的方式有哪些？\\n修改样式一定导致重绘吗？重绘一定导致重排吗？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"如果JavaScript做了修改DOM元素的几何属性（位置、尺寸）等操作，将会重新计算style，并且需要更新布局树，然后执行后面的渲染操作，即从1~9的步骤需要重新执行一遍。这个过程叫“重排”。\\n如果JavaScript修改了DOM的非几何属性，如修改了元素的背景颜色，不需要更新布局树和重新构建分层树，只需要重新绘制。\\n在页面运行中，应该尽量避免重排和重绘，以提升渲染性能。\\n\\n减少回流和重绘的方式有（原理和细节请参考知识点链接）\\n1、避免元素影响到所在文档流\\n用绝对定位（position: absolute;）使元素脱离文档流。\\n\\n如果使用CSS的transform属性实现动画，则不需要重排和重绘，直接在合成线程合成动画操作，即省略了3、4、5三个阶段。由于没有占用主线程资源，并且跳过重排和重绘阶段，因此这样性能最高。\\n\\n2、读写分离\\n如果需要写样式之后再读取，应该先批量写完，然后再一起读取，防止频繁回流。\\n如果需要根据当前的样式设置新样式，应该先缓存当前样式，然后批量更新样式。\\n\\n3、集中改变样式\\n避免多次修改元素样式，最好集中一次修改元素的style text，或者通过class name来控制样式。防止频繁触发回流。\\n\\n4、离线改变DOM\\n如果需要进行多个DOM操作（添加、删除、修改），不要在当前的DOM中连续操作（如循环插入li）。\\n\\n在要操作DOM之前，通过display隐藏DOM，当操作完成之后，才将元素的display属性为可见，因为不可见的元素不会触发重排和重绘。\\n\\n通过使用DocumentFragment创建一个dom碎片,在它上面批量操作DOM，操作完成之后，再添加到文档中，这样只会触发一次重排。\\n复制节点，在副本上操作，然后替换原节点。\\n重绘不一定导致重排，重排一定导致重绘。\\n\"}]}",
      "quizes": ["5", "12", "14"]
    },
    {
      "id": "202",
      "title": "用户页面打开很慢，有哪些优化方式？",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "加载阶段性能优化",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9#glrJm"
        }
      ],
      "category": "性能优化",
      "tags": ["美团"],
      "question": "{\"ops\":[{\"insert\":\"用户页面打开很慢，有哪些优化方式？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"优化方法可以分为以下几类（具体的优化方法请参考知识点链接）\\n1、减少需要请求的资源尺寸：资源压缩、删除冗余代码和其他资源，或者使用尺寸更小的资源\\n2、减少请求数量\\n3、缓存\\n4、并行请求\\n5、按需加载\\n6、预加载\\n7、其他注意事项\\n8、服务端渲染和预渲染。\\n\"}]}",
      "quizes": ["5", "12"]
    },
    {
      "id": "203",
      "title": "css和js加载，是同步还是异步？",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "渲染过程",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lfg9g9#qTHYu"
        }
      ],
      "category": "性能优化",
      "tags": ["拼多多"],
      "question": "{\"ops\":[{\"insert\":\"css和js加载，是同步还是异步？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"css加载不会阻塞html解析，但是渲染会等待css下载并解析完才能进行。\\njs的执行需要等待css下载完成。\\njs执行默认是会阻塞html解析的，给script标签加defer和async属性，或者采用动态创建script标签方式，js就不会阻塞html。\\n\"}]}",
      "quizes": ["5", "12"]
    },
    {
      "id": "204",
      "title": "盒模型",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "盒模型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ccfywz#AfNHJ"
        }
      ],
      "category": "前端编程基础/css/盒模型",
      "tags": [
        "网易",
        "字节",
        "美团",
        "快手",
        "拼多多",
        "百度",
        "阿里",
        "腾讯",
        "京东"
      ],
      "question": "{\"ops\":[{\"insert\":\"介绍下css的盒模型。\\n标准盒模型和怪异盒模型是什么？\\nie 盒模型和 w3c 盒模型的区别 如何使用ie的盒模型\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"CSS把每个元素视为一个盒子，每个盒子包括分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分。这种对界面元素的抽象，称为盒模型。\\n    盒模型是CSS布局的基本单元。\\n\\n有两种盒模型：IE盒模型（也称怪异盒模型）（border-box）、W3C标准盒模型（content-box）\\nIE盒模型和W3C标准盒模型的区别：\\nW3C标准盒模型：属性width，height只包含内容content，不包含border和padding。\\nIE盒模型：属性width，height包含content、border和padding，指的是content +padding+border。\\n\"}]}",
      "quizes": ["5", "13", "14"]
    },
    {
      "id": "205",
      "title": "盒模型盒子的宽度计算",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "盒模型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ccfywz#AfNHJ"
        }
      ],
      "category": "前端编程基础/css/盒模型",
      "tags": ["百度"],
      "question": "{\"ops\":[{\"insert\":\"一个盒子，宽度设为100px，padding设为100px，整个在页面占多少px？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"盒子宽度 = width + padding + border + marign。\\n由于padding包括padding-left和padding-right，所以这个盒子水平占据100px + 100px × 2 = 300px。\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "206",
      "title": "两种盒模型对比",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "盒模型",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ccfywz#AfNHJ"
        }
      ],
      "category": "前端编程基础/css/盒模型",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"<div style=\\\"width: 200px;padding: 10px;margin: 20px\\\"><div>\"},{\"attributes\":{\"code-block\":true},\"insert\":\"\\n\"},{\"insert\":\"在两种盒模型下获取div的宽度分别是多少？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"div的宽度指通过div.clientWidth获取的宽度，这个宽度包括content、padding和border。\\n标准盒模width指的是content的宽度，因此获取的宽度为200px + 10 × 2 = 220px。\\n怪异盒模型width包括content、border和padding，因此width是200px。\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "207",
      "title": "有哪些CSS选择器",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "CSS选择器",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dvzwmo"
        }
      ],
      "category": "前端编程基础/css/选择器",
      "tags": ["百度", "滴滴", "京东"],
      "question": "{\"ops\":[{\"insert\":\"介绍一下都有哪些CSS选择器。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"1、id选择器（#myid）\\n2、类选择器（.my-classname）\\n3、标签选择器（div,h1,p）\\n4、后代选择器（h1 p）后代选择器的祖先和后代之间用空格分割\\n5、相邻后代选择器（子）选择器（ul>li）\\n6、兄弟选择器（li~a）\\n7、相邻兄弟选择器（li+a）\\n8、属性选择器（a[\"},{\"attributes\":{\"color\":\"#ce9178\"},\"insert\":\"rel=\\\"external\\\"\"},{\"insert\":\"]）\\n9、伪类选择器（a:hover,li:nth-child）\\n10、伪元素选择器（::before、 ::after）\\n11、通配符选择器（*）\\n\"}]}",
      "quizes": ["5", "13", "14"]
    },
    {
      "id": "208",
      "title": "css优先级",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "CSS优先级",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dvzwmo#uAdDb"
        }
      ],
      "category": "前端编程基础/css/优先级",
      "tags": ["百度", "阿里", "滴滴", "京东", "快手", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"说一下CSS优先级的计算规则？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"对于每条CSS规则，生成一个优先级四元组<内联,ID,Class|属性|伪类,元素选择器>。\\n每一位的数值计算方法是，在规则中选择器出现的个数。\\n两条规则之间对比，从左到右对比，数值大的规则优先级高。\\n如果某一位相同，对比下一位。\\n\"}]}",
      "quizes": ["5", "13", "14"]
    },
    {
      "id": "209",
      "title": "css优先级计算",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "CSS优先级",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dvzwmo#uAdDb"
        }
      ],
      "category": "前端编程基础/css/优先级",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"判断以下选择器优先级顺序\\n1、#foo div\\n2、#foo .bar div\\n3、#foo~.bar div\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"根据知识点中介绍，这3个选择器优先级计算结果为：\\n0,1,0,1\\n0,1,1,1\\n0,1,1,1\\n后两个优先级计算结果相同，则后出现的优先级更高\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "210",
      "title": "div .div #div div>div>div优先级",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "CSS优先级",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dvzwmo#uAdDb"
        }
      ],
      "category": "前端编程基础/css/优先级",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"div, .div, #div, div>div>div这几个选择器优先级排序？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"根据知识点中介绍，这4个选择器优先级计算结果为：\\n① 0,0,0,1\\n② 0,0,1,0\\n③ 0,1,0,0\\n④ 0,0,0,3\\n因此优先级排序为③, ②, ④, ①\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "211",
      "title": "class、id、tag 的优先级",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "CSS优先级",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dvzwmo#uAdDb"
        }
      ],
      "category": "前端编程基础/css/优先级",
      "tags": ["美团"],
      "question": "{\"ops\":[{\"insert\":\"class、id、tag 的优先级？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"id > class > tag\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "212",
      "title": "为什么不推荐用多层css选择器",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "选择器的匹配",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dvzwmo#tjwW7"
        }
      ],
      "category": "前端编程基础/css/选择器",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"为什么不推荐用多层css选择器？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"由于选择器的匹配需要在整个DOM树中查找节点，层级越高性能越低，因此不建议CSS选择器层级太多。\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "213",
      "title": "css选择器处理",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "选择器的匹配",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/dvzwmo#tjwW7"
        }
      ],
      "category": "前端编程基础/css/选择器",
      "tags": ["京东"],
      "question": "{\"ops\":[{\"insert\":\"div .child p是是从左边往右边开始定位还是从右边往左边开始？为什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"当存在后代选择器时候，CSS选择器的匹配是从右往左的，原因是从左往右匹配的话，需要遍历DOM树，可能会有多次回溯，而从右往左的话，先匹配所有的子节点选择器，然后向上查找，这样性能更好。\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "214",
      "title": "css居中",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "CSS居中布局",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/mc301g"
        }
      ],
      "category": "前端编程基础/css/布局",
      "tags": ["网易", "字节", "快手", "拼多多", "百度", "腾讯", "阿里"],
      "question": "{\"ops\":[{\"insert\":\"css如何水平居中和垂直居中？那种最好？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"请参考知识点说明\\n\"}]}",
      "quizes": ["5", "13", "14"]
    },
    {
      "id": "215",
      "title": "多列等高布局",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "多列等高布局",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/oiq1nx"
        }
      ],
      "category": "前端编程基础/css/布局",
      "tags": ["字节", "阿里"],
      "question": "{\"ops\":[{\"insert\":\"实现多列等高布局\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"请参考知识点链接\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "216",
      "title": "元素margin合并",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "margin塌陷和BFC",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ccfywz#jrw92"
        }
      ],
      "category": "前端编程基础/css/bfc",
      "tags": ["百度", "网易", "字节", "拼多多"],
      "question": "{\"ops\":[{\"insert\":\"两个兄弟盒子A在上、B在下，A margin-bottom：20px，B margin-top：30px A和B的最终距离是多少？\\nA和B是父子关系A在外、B在内，A margin-top：30px ，B margin-top： 20px，A和B之间的距离是多少？\\n边距塌陷的解决方法是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"30px\\n30px\\n解决方法是触发BFC\\n\"}]}",
      "quizes": ["5", "13", "14"]
    },
    {
      "id": "217",
      "title": "BFC、IFC",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "BFC和IFC",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ccfywz#aQESG"
        }
      ],
      "category": "前端编程基础/css/bfc",
      "tags": ["百度", "腾讯", "字节", "美团", "滴滴", "快手", "网易"],
      "question": "{\"ops\":[{\"insert\":\"说一下对BFC和IFC的理解？\\n它们的区别？它们都有什么作用？\\n怎么形成BFC和IFC？overflow除了hidden还有哪个值可以触发BFC？position除了absolute还有哪个值可以触发？\\nBFC会与float元素相互覆盖吗？为什么？举例说明。\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"请参考知识点链接\\n\"}]}",
      "quizes": ["5", "13", "14"]
    },
    {
      "id": "218",
      "title": "如何清除浮动",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "清除浮动",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ccfywz#xUnIO"
        }
      ],
      "category": "前端编程基础/css/定位",
      "tags": ["百度", "阿里", "美团"],
      "question": "{\"ops\":[{\"insert\":\"为什么需要清除浮动？\\n如何清除浮动？\\nclear为什么能清除浮动？\\noverflow: hidden为什么能清除浮动？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"浮动的元素会造成父元素高度塌陷，因此需要清除浮动。\\n有3种办法：1. 在浮动元素后面增加一个元素，设置clear: both；2. 父元素设置伪元素，给伪元素设置clear: both；3. 父元素设置overflow: hidden。\\n设置clear的元素不受前面浮动元素影响，位置会放在浮动元素后面，因此可以把父元素撑开。\\noverflow: hidden让父元素形成一个BFC，所以可以清除浮动。\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "219",
      "title": "block、inline和inline-block的元素有什么差别",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "块元素和行内元素",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ccfywz#dxbQG"
        }
      ],
      "category": "前端编程基础/css/盒模型",
      "tags": ["滴滴", "百度"],
      "question": "{\"ops\":[{\"insert\":\"block、inline和inline-block的元素有什么差别\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"block   块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\\ninline  行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。\\ninline-block 默认宽度为内容宽度，可以设置宽高，同行显示。\\n\"}]}",
      "quizes": ["", "14"]
    },
    {
      "id": "220",
      "title": "display属性",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "块元素和行内元素",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ccfywz#dxbQG"
        }
      ],
      "category": "前端编程基础/css/盒模型",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"CSS的display有哪些值？\\ninline和block的区别？\\ninline的元素能设置宽高、margin属性吗？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"display的属性值：\\n● block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\\n● none  元素不显示，并从文档流中移除。\\n● inline    行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。\\n● inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。\\ninline元素可以设置水平的padding、margin，但不能设置垂直的padding和margin，也不能设置width和height。\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "221",
      "title": "怎么实现0.5px的边框",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "发丝线",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/lgp0rl#JsN8H"
        }
      ],
      "category": "前端编程基础/css/技巧",
      "tags": ["字节"],
      "question": "{\"ops\":[{\"insert\":\"怎么实现0.5px的边框？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"直接设置0.5px\\ntransform\\n线性渐变\\nbox-shadow\\nsvg\\nviewport scale缩放\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "222",
      "title": "使用CSS设定图片容器宽高比",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "自适应正方形",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ts1uop"
        }
      ],
      "category": "前端编程基础/css/技巧",
      "tags": ["百度", "字节"],
      "question": "{\"ops\":[{\"insert\":\"如何使用CSS设定图片容器宽高比？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"核心思想是让子元素撑起来父元素高度，子元素根据父元素宽度撑起父元素高度，从而让父元素宽高成一定比例。\\n具体的实现请阅读知识点。\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "223",
      "title": "自适应正方形",
      "type": 1,
      "level": 12,
      "knowledge": [
        {
          "name": "自适应正方形",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ts1uop"
        }
      ],
      "category": "前端编程基础/css/技巧",
      "tags": ["滴滴"],
      "question": "{\"ops\":[{\"insert\":\"实现自适应正方形\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"有两种方法：1. 用子元素的padding-top或者padding-bottom撑起父元素；2. 用子元素的伪元素::after将父元素撑起来。\\n\"}]}",
      "quizes": ["5", "13"]
    },
    {
      "id": "224",
      "title": "position和float的区别",
      "type": 1,
      "level": 14,
      "knowledge": [
        {
          "name": "布局基础",
          "url": "https://www.yuque.com/baiyueguang-rfnbu/tr4d0i/ccfywz"
        }
      ],
      "category": "前端编程基础/css/定位",
      "tags": ["阿里", "美团"],
      "question": "{\"ops\":[{\"insert\":\"position和float的区别是什么？\\n\"}]}",
      "options": null,
      "answer": null,
      "answerkey": "{\"ops\":[{\"insert\":\"float和position是两种不同的布局方式。float让块级元素可以在同一行布局，并且行内元素会浮动在其周围，position让元素相对于其他元素定位。\\n两者层级不同，float元素低于position的元素。\\n两者适用场景不同，float用于图片周围浮动文本、信息流等场景，position用在固定某个元素位置，如导航栏等场景。\\n\"}]}",
      "quizes": ["5", "13"]
    }
  ],
  "title": "前端大厂面试真题"
}
